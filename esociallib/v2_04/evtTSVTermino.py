#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Oct 10 00:42:27 2017 by generateDS.py version 2.28b.
# Python 2.7.12 (default, Nov 19 2016, 06:48:10)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('--no-process-includes', '')
#   ('-o', 'esociallib/v2_04/evtTSVTermino.py')
#
# Command line arguments:
#   schemas/v2_04/evtTSVTermino.xsd
#
# Command line:
#   /usr/local/bin/generateDS --no-process-includes -o "esociallib/v2_04/evtTSVTermino.py" schemas/v2_04/evtTSVTermino.xsd
#
# Current working directory (os.getcwd()):
#   esociallib
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class eSocial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evtTSVTermino=None, Signature=None):
        self.original_tagname_ = None
        self.evtTSVTermino = evtTSVTermino
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eSocial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eSocial.subclass:
            return eSocial.subclass(*args_, **kwargs_)
        else:
            return eSocial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evtTSVTermino(self): return self.evtTSVTermino
    def set_evtTSVTermino(self, evtTSVTermino): self.evtTSVTermino = evtTSVTermino
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def hasContent_(self):
        if (
            self.evtTSVTermino is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eSocial', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eSocial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eSocial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eSocial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eSocial'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='eSocial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.evtTSVTermino is not None:
            self.evtTSVTermino.export(outfile, level, namespace_, name_='evtTSVTermino', pretty_print=pretty_print)
        if self.Signature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSignature>%s</%sSignature>%s' % ('ds:', self.gds_encode(self.gds_format_string(quote_xml(self.Signature), input_name='Signature')), 'ds:', eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'evtTSVTermino':
            obj_ = evtTSVTermino.factory()
            obj_.build(child_)
            self.evtTSVTermino = obj_
            obj_.original_tagname_ = 'evtTSVTermino'
        elif nodeName_ == 'Signature':
            Signature_ = child_.text
            Signature_ = self.gds_validate_string(Signature_, node, 'Signature')
            self.Signature = Signature_
# end class eSocial


class evtTSVTermino(GeneratedsSuper):
    """Evento Trabalhador Sem Vínculo de Emprego/Estatutário - Término"""
    subclass = None
    superclass = None
    def __init__(self, Id=None, ideEvento=None, ideEmpregador=None, ideTrabSemVinculo=None, infoTSVTermino=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.ideEvento = ideEvento
        self.ideEmpregador = ideEmpregador
        self.ideTrabSemVinculo = ideTrabSemVinculo
        self.infoTSVTermino = infoTSVTermino
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, evtTSVTermino)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if evtTSVTermino.subclass:
            return evtTSVTermino.subclass(*args_, **kwargs_)
        else:
            return evtTSVTermino(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideEvento(self): return self.ideEvento
    def set_ideEvento(self, ideEvento): self.ideEvento = ideEvento
    def get_ideEmpregador(self): return self.ideEmpregador
    def set_ideEmpregador(self, ideEmpregador): self.ideEmpregador = ideEmpregador
    def get_ideTrabSemVinculo(self): return self.ideTrabSemVinculo
    def set_ideTrabSemVinculo(self, ideTrabSemVinculo): self.ideTrabSemVinculo = ideTrabSemVinculo
    def get_infoTSVTermino(self): return self.infoTSVTermino
    def set_infoTSVTermino(self, infoTSVTermino): self.infoTSVTermino = infoTSVTermino
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.ideEvento is not None or
            self.ideEmpregador is not None or
            self.ideTrabSemVinculo is not None or
            self.infoTSVTermino is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='evtTSVTermino', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('evtTSVTermino')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='evtTSVTermino')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='evtTSVTermino', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='evtTSVTermino'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='evtTSVTermino', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideEvento is not None:
            self.ideEvento.export(outfile, level, namespace_, name_='ideEvento', pretty_print=pretty_print)
        if self.ideEmpregador is not None:
            self.ideEmpregador.export(outfile, level, namespace_, name_='ideEmpregador', pretty_print=pretty_print)
        if self.ideTrabSemVinculo is not None:
            self.ideTrabSemVinculo.export(outfile, level, namespace_, name_='ideTrabSemVinculo', pretty_print=pretty_print)
        if self.infoTSVTermino is not None:
            self.infoTSVTermino.export(outfile, level, namespace_, name_='infoTSVTermino', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideEvento':
            obj_ = TIdeEveTrab.factory()
            obj_.build(child_)
            self.ideEvento = obj_
            obj_.original_tagname_ = 'ideEvento'
        elif nodeName_ == 'ideEmpregador':
            obj_ = TEmpregador.factory()
            obj_.build(child_)
            self.ideEmpregador = obj_
            obj_.original_tagname_ = 'ideEmpregador'
        elif nodeName_ == 'ideTrabSemVinculo':
            obj_ = ideTrabSemVinculo.factory()
            obj_.build(child_)
            self.ideTrabSemVinculo = obj_
            obj_.original_tagname_ = 'ideTrabSemVinculo'
        elif nodeName_ == 'infoTSVTermino':
            obj_ = infoTSVTermino.factory()
            obj_.build(child_)
            self.infoTSVTermino = obj_
            obj_.original_tagname_ = 'infoTSVTermino'
# end class evtTSVTermino


class ideTrabSemVinculo(GeneratedsSuper):
    """Identificação do Trabalhador Sem Vínculo"""
    subclass = None
    superclass = None
    def __init__(self, cpfTrab=None, nisTrab=None, codCateg=None):
        self.original_tagname_ = None
        self.cpfTrab = cpfTrab
        self.nisTrab = nisTrab
        self.codCateg = codCateg
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideTrabSemVinculo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideTrabSemVinculo.subclass:
            return ideTrabSemVinculo.subclass(*args_, **kwargs_)
        else:
            return ideTrabSemVinculo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpfTrab(self): return self.cpfTrab
    def set_cpfTrab(self, cpfTrab): self.cpfTrab = cpfTrab
    def get_nisTrab(self): return self.nisTrab
    def set_nisTrab(self, nisTrab): self.nisTrab = nisTrab
    def get_codCateg(self): return self.codCateg
    def set_codCateg(self, codCateg): self.codCateg = codCateg
    def hasContent_(self):
        if (
            self.cpfTrab is not None or
            self.nisTrab is not None or
            self.codCateg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideTrabSemVinculo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideTrabSemVinculo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideTrabSemVinculo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideTrabSemVinculo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideTrabSemVinculo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideTrabSemVinculo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cpfTrab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpfTrab>%s</%scpfTrab>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cpfTrab), input_name='cpfTrab')), namespace_, eol_))
        if self.nisTrab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snisTrab>%s</%snisTrab>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nisTrab), input_name='nisTrab')), namespace_, eol_))
        if self.codCateg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodCateg>%s</%scodCateg>%s' % (namespace_, self.gds_format_integer(self.codCateg, input_name='codCateg'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cpfTrab':
            cpfTrab_ = child_.text
            cpfTrab_ = self.gds_validate_string(cpfTrab_, node, 'cpfTrab')
            self.cpfTrab = cpfTrab_
        elif nodeName_ == 'nisTrab':
            nisTrab_ = child_.text
            nisTrab_ = self.gds_validate_string(nisTrab_, node, 'nisTrab')
            self.nisTrab = nisTrab_
        elif nodeName_ == 'codCateg':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codCateg')
            self.codCateg = ival_
# end class ideTrabSemVinculo


class cpfTrab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cpfTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cpfTrab.subclass:
            return cpfTrab.subclass(*args_, **kwargs_)
        else:
            return cpfTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cpfTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpfTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cpfTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cpfTrab', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cpfTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cpfTrab', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cpfTrab


class nisTrab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nisTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nisTrab.subclass:
            return nisTrab.subclass(*args_, **kwargs_)
        else:
            return nisTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nisTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nisTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nisTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nisTrab', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nisTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nisTrab', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nisTrab


class codCateg(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codCateg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codCateg.subclass:
            return codCateg.subclass(*args_, **kwargs_)
        else:
            return codCateg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codCateg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codCateg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codCateg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codCateg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codCateg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codCateg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codCateg


class infoTSVTermino(GeneratedsSuper):
    """Trabalhador Sem Vínculo de Emprego - Término"""
    subclass = None
    superclass = None
    def __init__(self, dtTerm=None, mtvDesligTSV=None, verbasResc=None, quarentena=None):
        self.original_tagname_ = None
        if isinstance(dtTerm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dtTerm, '%Y-%m-%d').date()
        else:
            initvalue_ = dtTerm
        self.dtTerm = initvalue_
        self.mtvDesligTSV = mtvDesligTSV
        self.verbasResc = verbasResc
        self.quarentena = quarentena
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoTSVTermino)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoTSVTermino.subclass:
            return infoTSVTermino.subclass(*args_, **kwargs_)
        else:
            return infoTSVTermino(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dtTerm(self): return self.dtTerm
    def set_dtTerm(self, dtTerm): self.dtTerm = dtTerm
    def get_mtvDesligTSV(self): return self.mtvDesligTSV
    def set_mtvDesligTSV(self, mtvDesligTSV): self.mtvDesligTSV = mtvDesligTSV
    def get_verbasResc(self): return self.verbasResc
    def set_verbasResc(self, verbasResc): self.verbasResc = verbasResc
    def get_quarentena(self): return self.quarentena
    def set_quarentena(self, quarentena): self.quarentena = quarentena
    def hasContent_(self):
        if (
            self.dtTerm is not None or
            self.mtvDesligTSV is not None or
            self.verbasResc is not None or
            self.quarentena is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoTSVTermino', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoTSVTermino')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoTSVTermino')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoTSVTermino', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoTSVTermino'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoTSVTermino', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dtTerm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdtTerm>%s</%sdtTerm>%s' % (namespace_, self.gds_format_date(self.dtTerm, input_name='dtTerm'), namespace_, eol_))
        if self.mtvDesligTSV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smtvDesligTSV>%s</%smtvDesligTSV>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mtvDesligTSV), input_name='mtvDesligTSV')), namespace_, eol_))
        if self.verbasResc is not None:
            self.verbasResc.export(outfile, level, namespace_, name_='verbasResc', pretty_print=pretty_print)
        if self.quarentena is not None:
            self.quarentena.export(outfile, level, namespace_, name_='quarentena', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dtTerm':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dtTerm = dval_
        elif nodeName_ == 'mtvDesligTSV':
            mtvDesligTSV_ = child_.text
            mtvDesligTSV_ = self.gds_validate_string(mtvDesligTSV_, node, 'mtvDesligTSV')
            self.mtvDesligTSV = mtvDesligTSV_
        elif nodeName_ == 'verbasResc':
            obj_ = verbasResc.factory()
            obj_.build(child_)
            self.verbasResc = obj_
            obj_.original_tagname_ = 'verbasResc'
        elif nodeName_ == 'quarentena':
            obj_ = quarentena.factory()
            obj_.build(child_)
            self.quarentena = obj_
            obj_.original_tagname_ = 'quarentena'
# end class infoTSVTermino


class dtTerm(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dtTerm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dtTerm.subclass:
            return dtTerm.subclass(*args_, **kwargs_)
        else:
            return dtTerm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dtTerm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dtTerm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dtTerm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dtTerm', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dtTerm'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dtTerm', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dtTerm


class mtvDesligTSV(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mtvDesligTSV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mtvDesligTSV.subclass:
            return mtvDesligTSV.subclass(*args_, **kwargs_)
        else:
            return mtvDesligTSV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mtvDesligTSV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mtvDesligTSV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mtvDesligTSV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mtvDesligTSV', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mtvDesligTSV'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='mtvDesligTSV', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mtvDesligTSV


class verbasResc(GeneratedsSuper):
    """Registro onde são prestadas as informações relativas às verbas
    rescisórias do trabalhador, se houver."""
    subclass = None
    superclass = None
    def __init__(self, dmDev=None, procJudTrab=None, infoMV=None):
        self.original_tagname_ = None
        if dmDev is None:
            self.dmDev = []
        else:
            self.dmDev = dmDev
        if procJudTrab is None:
            self.procJudTrab = []
        else:
            self.procJudTrab = procJudTrab
        self.infoMV = infoMV
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, verbasResc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if verbasResc.subclass:
            return verbasResc.subclass(*args_, **kwargs_)
        else:
            return verbasResc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dmDev(self): return self.dmDev
    def set_dmDev(self, dmDev): self.dmDev = dmDev
    def add_dmDev(self, value): self.dmDev.append(value)
    def insert_dmDev_at(self, index, value): self.dmDev.insert(index, value)
    def replace_dmDev_at(self, index, value): self.dmDev[index] = value
    def get_procJudTrab(self): return self.procJudTrab
    def set_procJudTrab(self, procJudTrab): self.procJudTrab = procJudTrab
    def add_procJudTrab(self, value): self.procJudTrab.append(value)
    def insert_procJudTrab_at(self, index, value): self.procJudTrab.insert(index, value)
    def replace_procJudTrab_at(self, index, value): self.procJudTrab[index] = value
    def get_infoMV(self): return self.infoMV
    def set_infoMV(self, infoMV): self.infoMV = infoMV
    def hasContent_(self):
        if (
            self.dmDev or
            self.procJudTrab or
            self.infoMV is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='verbasResc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('verbasResc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='verbasResc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='verbasResc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='verbasResc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='verbasResc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dmDev_ in self.dmDev:
            dmDev_.export(outfile, level, namespace_, name_='dmDev', pretty_print=pretty_print)
        for procJudTrab_ in self.procJudTrab:
            procJudTrab_.export(outfile, level, namespace_, name_='procJudTrab', pretty_print=pretty_print)
        if self.infoMV is not None:
            self.infoMV.export(outfile, level, namespace_, name_='infoMV', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dmDev':
            obj_ = dmDev.factory()
            obj_.build(child_)
            self.dmDev.append(obj_)
            obj_.original_tagname_ = 'dmDev'
        elif nodeName_ == 'procJudTrab':
            obj_ = procJudTrab.factory()
            obj_.build(child_)
            self.procJudTrab.append(obj_)
            obj_.original_tagname_ = 'procJudTrab'
        elif nodeName_ == 'infoMV':
            obj_ = infoMV.factory()
            obj_.build(child_)
            self.infoMV = obj_
            obj_.original_tagname_ = 'infoMV'
# end class verbasResc


class dmDev(GeneratedsSuper):
    """Identificação de cada um dos demonstrativos de valores devidos ao
    trabalhador antes das retenções de pensão alimentícia e IRRF.
    (As retenções de pensão alimentícia e IRRF devem ser realizadas
    no ato do pagamento e, portanto, são informadas no evento
    S-1210). Para as rubricas cujo {codIncCP} = [31, 32, 34, 35], o
    somatório do valor das rubricas cujo ({tpRubr} = [2,4]) deverá
    ser maior ou igual ao somatório do valor das rubricas cujo
    ({tpRubr} = [1,3]), considerando cada um dos códigos {codIncCP}
    individualmente. O somatório dos Vencimentos deve ser maior ou
    igual ao somatório dos Descontos. As informações dos campos
    {ideEstabLot/nrInsc}, {detVerbas/codRubr},
    {ideEstabLot/codLotacao} vinculadas a este registro, devem
    constar nas respectivas tabelas S-1005, S-1010 e S-1020, no mês
    da data do desligamento informada no campo {dtTerm}."""
    subclass = None
    superclass = None
    def __init__(self, ideDmDev=None, ideEstabLot=None):
        self.original_tagname_ = None
        self.ideDmDev = ideDmDev
        if ideEstabLot is None:
            self.ideEstabLot = []
        else:
            self.ideEstabLot = ideEstabLot
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dmDev)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dmDev.subclass:
            return dmDev.subclass(*args_, **kwargs_)
        else:
            return dmDev(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideDmDev(self): return self.ideDmDev
    def set_ideDmDev(self, ideDmDev): self.ideDmDev = ideDmDev
    def get_ideEstabLot(self): return self.ideEstabLot
    def set_ideEstabLot(self, ideEstabLot): self.ideEstabLot = ideEstabLot
    def add_ideEstabLot(self, value): self.ideEstabLot.append(value)
    def insert_ideEstabLot_at(self, index, value): self.ideEstabLot.insert(index, value)
    def replace_ideEstabLot_at(self, index, value): self.ideEstabLot[index] = value
    def hasContent_(self):
        if (
            self.ideDmDev is not None or
            self.ideEstabLot
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dmDev', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dmDev')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dmDev')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dmDev', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dmDev'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dmDev', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideDmDev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sideDmDev>%s</%sideDmDev>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ideDmDev), input_name='ideDmDev')), namespace_, eol_))
        for ideEstabLot_ in self.ideEstabLot:
            ideEstabLot_.export(outfile, level, namespace_, name_='ideEstabLot', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideDmDev':
            ideDmDev_ = child_.text
            ideDmDev_ = self.gds_validate_string(ideDmDev_, node, 'ideDmDev')
            self.ideDmDev = ideDmDev_
        elif nodeName_ == 'ideEstabLot':
            obj_ = ideEstabLot.factory()
            obj_.build(child_)
            self.ideEstabLot.append(obj_)
            obj_.original_tagname_ = 'ideEstabLot'
# end class dmDev


class ideDmDev(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideDmDev)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideDmDev.subclass:
            return ideDmDev.subclass(*args_, **kwargs_)
        else:
            return ideDmDev(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideDmDev', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideDmDev')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideDmDev')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideDmDev', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideDmDev'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideDmDev', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ideDmDev


class ideEstabLot(GeneratedsSuper):
    """Identificação do Estabelecimento/Lotação no qual o trabalhador
    possui remuneração no período de apuração. O estabelecimento
    identificado no registro pode ser: o número do CNPJ do
    estabelecimento da própria empresa (matriz/filial), o número da
    obra (própria) no CNO, ou o número do CAEPF (no caso de pessoa
    física obrigada a inscrição no cadastro de atividades
    específicas da pessoa física). No caso específico do trabalhador
    doméstico, o estabelecimento deve ser o próprio CPF do
    empregador."""
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None, codLotacao=None, detVerbas=None, infoSaudeColet=None, infoAgNocivo=None, infoSimples=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
        self.codLotacao = codLotacao
        if detVerbas is None:
            self.detVerbas = []
        else:
            self.detVerbas = detVerbas
        self.infoSaudeColet = infoSaudeColet
        self.infoAgNocivo = infoAgNocivo
        self.infoSimples = infoSimples
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideEstabLot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideEstabLot.subclass:
            return ideEstabLot.subclass(*args_, **kwargs_)
        else:
            return ideEstabLot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def get_codLotacao(self): return self.codLotacao
    def set_codLotacao(self, codLotacao): self.codLotacao = codLotacao
    def get_detVerbas(self): return self.detVerbas
    def set_detVerbas(self, detVerbas): self.detVerbas = detVerbas
    def add_detVerbas(self, value): self.detVerbas.append(value)
    def insert_detVerbas_at(self, index, value): self.detVerbas.insert(index, value)
    def replace_detVerbas_at(self, index, value): self.detVerbas[index] = value
    def get_infoSaudeColet(self): return self.infoSaudeColet
    def set_infoSaudeColet(self, infoSaudeColet): self.infoSaudeColet = infoSaudeColet
    def get_infoAgNocivo(self): return self.infoAgNocivo
    def set_infoAgNocivo(self, infoAgNocivo): self.infoAgNocivo = infoAgNocivo
    def get_infoSimples(self): return self.infoSimples
    def set_infoSimples(self, infoSimples): self.infoSimples = infoSimples
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None or
            self.codLotacao is not None or
            self.detVerbas or
            self.infoSaudeColet is not None or
            self.infoAgNocivo is not None or
            self.infoSimples is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideEstabLot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideEstabLot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideEstabLot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideEstabLot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideEstabLot'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideEstabLot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
        if self.codLotacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodLotacao>%s</%scodLotacao>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codLotacao), input_name='codLotacao')), namespace_, eol_))
        for detVerbas_ in self.detVerbas:
            detVerbas_.export(outfile, level, namespace_, name_='detVerbas', pretty_print=pretty_print)
        if self.infoSaudeColet is not None:
            self.infoSaudeColet.export(outfile, level, namespace_, name_='infoSaudeColet', pretty_print=pretty_print)
        if self.infoAgNocivo is not None:
            self.infoAgNocivo.export(outfile, level, namespace_, name_='infoAgNocivo', pretty_print=pretty_print)
        if self.infoSimples is not None:
            self.infoSimples.export(outfile, level, namespace_, name_='infoSimples', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
        elif nodeName_ == 'codLotacao':
            codLotacao_ = child_.text
            codLotacao_ = self.gds_validate_string(codLotacao_, node, 'codLotacao')
            self.codLotacao = codLotacao_
        elif nodeName_ == 'detVerbas':
            obj_ = detVerbas.factory()
            obj_.build(child_)
            self.detVerbas.append(obj_)
            obj_.original_tagname_ = 'detVerbas'
        elif nodeName_ == 'infoSaudeColet':
            obj_ = TSaudeCol.factory()
            obj_.build(child_)
            self.infoSaudeColet = obj_
            obj_.original_tagname_ = 'infoSaudeColet'
        elif nodeName_ == 'infoAgNocivo':
            obj_ = infoAgNocivo.factory()
            obj_.build(child_)
            self.infoAgNocivo = obj_
            obj_.original_tagname_ = 'infoAgNocivo'
        elif nodeName_ == 'infoSimples':
            obj_ = infoSimples.factory()
            obj_.build(child_)
            self.infoSimples = obj_
            obj_.original_tagname_ = 'infoSimples'
# end class ideEstabLot


class tpInsc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpInsc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpInsc.subclass:
            return tpInsc.subclass(*args_, **kwargs_)
        else:
            return tpInsc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpInsc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpInsc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpInsc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpInsc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpInsc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpInsc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpInsc


class nrInsc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrInsc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrInsc.subclass:
            return nrInsc.subclass(*args_, **kwargs_)
        else:
            return nrInsc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrInsc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrInsc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrInsc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrInsc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrInsc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrInsc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrInsc


class codLotacao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codLotacao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codLotacao.subclass:
            return codLotacao.subclass(*args_, **kwargs_)
        else:
            return codLotacao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codLotacao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codLotacao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codLotacao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codLotacao', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codLotacao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codLotacao', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codLotacao


class detVerbas(GeneratedsSuper):
    """Registro onde são prestadas as informações relativas às verbas
    rescisórias do trabalhador, se houver."""
    subclass = None
    superclass = None
    def __init__(self, codRubr=None, ideTabRubr=None, qtdRubr=None, fatorRubr=None, vrUnit=None, vrRubr=None):
        self.original_tagname_ = None
        self.codRubr = codRubr
        self.ideTabRubr = ideTabRubr
        self.qtdRubr = qtdRubr
        self.fatorRubr = fatorRubr
        self.vrUnit = vrUnit
        self.vrRubr = vrRubr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detVerbas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detVerbas.subclass:
            return detVerbas.subclass(*args_, **kwargs_)
        else:
            return detVerbas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codRubr(self): return self.codRubr
    def set_codRubr(self, codRubr): self.codRubr = codRubr
    def get_ideTabRubr(self): return self.ideTabRubr
    def set_ideTabRubr(self, ideTabRubr): self.ideTabRubr = ideTabRubr
    def get_qtdRubr(self): return self.qtdRubr
    def set_qtdRubr(self, qtdRubr): self.qtdRubr = qtdRubr
    def get_fatorRubr(self): return self.fatorRubr
    def set_fatorRubr(self, fatorRubr): self.fatorRubr = fatorRubr
    def get_vrUnit(self): return self.vrUnit
    def set_vrUnit(self, vrUnit): self.vrUnit = vrUnit
    def get_vrRubr(self): return self.vrRubr
    def set_vrRubr(self, vrRubr): self.vrRubr = vrRubr
    def hasContent_(self):
        if (
            self.codRubr is not None or
            self.ideTabRubr is not None or
            self.qtdRubr is not None or
            self.fatorRubr is not None or
            self.vrUnit is not None or
            self.vrRubr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detVerbas', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detVerbas')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detVerbas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detVerbas', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detVerbas'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='detVerbas', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodRubr>%s</%scodRubr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codRubr), input_name='codRubr')), namespace_, eol_))
        if self.ideTabRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sideTabRubr>%s</%sideTabRubr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ideTabRubr), input_name='ideTabRubr')), namespace_, eol_))
        if self.qtdRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtdRubr>%s</%sqtdRubr>%s' % (namespace_, self.gds_format_float(self.qtdRubr, input_name='qtdRubr'), namespace_, eol_))
        if self.fatorRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfatorRubr>%s</%sfatorRubr>%s' % (namespace_, self.gds_format_float(self.fatorRubr, input_name='fatorRubr'), namespace_, eol_))
        if self.vrUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrUnit>%s</%svrUnit>%s' % (namespace_, self.gds_format_float(self.vrUnit, input_name='vrUnit'), namespace_, eol_))
        if self.vrRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrRubr>%s</%svrRubr>%s' % (namespace_, self.gds_format_float(self.vrRubr, input_name='vrRubr'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codRubr':
            codRubr_ = child_.text
            codRubr_ = self.gds_validate_string(codRubr_, node, 'codRubr')
            self.codRubr = codRubr_
        elif nodeName_ == 'ideTabRubr':
            ideTabRubr_ = child_.text
            ideTabRubr_ = self.gds_validate_string(ideTabRubr_, node, 'ideTabRubr')
            self.ideTabRubr = ideTabRubr_
        elif nodeName_ == 'qtdRubr':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'qtdRubr')
            self.qtdRubr = fval_
        elif nodeName_ == 'fatorRubr':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fatorRubr')
            self.fatorRubr = fval_
        elif nodeName_ == 'vrUnit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrUnit')
            self.vrUnit = fval_
        elif nodeName_ == 'vrRubr':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRubr')
            self.vrRubr = fval_
# end class detVerbas


class codRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codRubr.subclass:
            return codRubr.subclass(*args_, **kwargs_)
        else:
            return codRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codRubr


class ideTabRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideTabRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideTabRubr.subclass:
            return ideTabRubr.subclass(*args_, **kwargs_)
        else:
            return ideTabRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideTabRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideTabRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideTabRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideTabRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideTabRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideTabRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ideTabRubr


class qtdRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qtdRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qtdRubr.subclass:
            return qtdRubr.subclass(*args_, **kwargs_)
        else:
            return qtdRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qtdRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qtdRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qtdRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qtdRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qtdRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qtdRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qtdRubr


class fatorRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fatorRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fatorRubr.subclass:
            return fatorRubr.subclass(*args_, **kwargs_)
        else:
            return fatorRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fatorRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fatorRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fatorRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fatorRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fatorRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fatorRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fatorRubr


class vrUnit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrUnit.subclass:
            return vrUnit.subclass(*args_, **kwargs_)
        else:
            return vrUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrUnit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrUnit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrUnit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrUnit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrUnit


class vrRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrRubr.subclass:
            return vrRubr.subclass(*args_, **kwargs_)
        else:
            return vrRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrRubr


class infoAgNocivo(GeneratedsSuper):
    """Registro preenchido exclusivamente em relação a remuneração de
    trabalhador de categoria Avulso e Cooperado filiado a
    cooperativa de produção ou Cooperado filiado a cooperativa de
    trabalho que presta serviço a empresa, permitindo o detalhamento
    do grau de exposição do trabalhador aos agentes nocivos que
    ensejam a cobrança da contribuição adicional para financiamento
    dos benefícios de aposentadoria especial."""
    subclass = None
    superclass = None
    def __init__(self, grauExp=None):
        self.original_tagname_ = None
        self.grauExp = grauExp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoAgNocivo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoAgNocivo.subclass:
            return infoAgNocivo.subclass(*args_, **kwargs_)
        else:
            return infoAgNocivo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_grauExp(self): return self.grauExp
    def set_grauExp(self, grauExp): self.grauExp = grauExp
    def hasContent_(self):
        if (
            self.grauExp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoAgNocivo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoAgNocivo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoAgNocivo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoAgNocivo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoAgNocivo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoAgNocivo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.grauExp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgrauExp>%s</%sgrauExp>%s' % (namespace_, self.gds_format_integer(self.grauExp, input_name='grauExp'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'grauExp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'grauExp')
            self.grauExp = ival_
# end class infoAgNocivo


class grauExp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, grauExp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if grauExp.subclass:
            return grauExp.subclass(*args_, **kwargs_)
        else:
            return grauExp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='grauExp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('grauExp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='grauExp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='grauExp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='grauExp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='grauExp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class grauExp


class infoSimples(GeneratedsSuper):
    """Informação relativa a empresas enquadradas no Regime de Tributação
    Simples"""
    subclass = None
    superclass = None
    def __init__(self, indSimples=None):
        self.original_tagname_ = None
        self.indSimples = indSimples
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoSimples)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoSimples.subclass:
            return infoSimples.subclass(*args_, **kwargs_)
        else:
            return infoSimples(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indSimples(self): return self.indSimples
    def set_indSimples(self, indSimples): self.indSimples = indSimples
    def hasContent_(self):
        if (
            self.indSimples is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoSimples', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoSimples')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoSimples')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoSimples', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoSimples'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoSimples', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indSimples is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSimples>%s</%sindSimples>%s' % (namespace_, self.gds_format_integer(self.indSimples, input_name='indSimples'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indSimples':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indSimples')
            self.indSimples = ival_
# end class infoSimples


class indSimples(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indSimples)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indSimples.subclass:
            return indSimples.subclass(*args_, **kwargs_)
        else:
            return indSimples(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indSimples', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indSimples')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indSimples')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indSimples', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indSimples'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indSimples', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indSimples


class procJudTrab(GeneratedsSuper):
    """Informações sobre a existência de processos judiciais do trabalhador
    com decisão favorável quanto à não incidência de contribuição
    previdenciária e/ou Imposto de Renda"""
    subclass = None
    superclass = None
    def __init__(self, tpTrib=None, nrProcJud=None, codSusp=None):
        self.original_tagname_ = None
        self.tpTrib = tpTrib
        self.nrProcJud = nrProcJud
        self.codSusp = codSusp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procJudTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procJudTrab.subclass:
            return procJudTrab.subclass(*args_, **kwargs_)
        else:
            return procJudTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpTrib(self): return self.tpTrib
    def set_tpTrib(self, tpTrib): self.tpTrib = tpTrib
    def get_nrProcJud(self): return self.nrProcJud
    def set_nrProcJud(self, nrProcJud): self.nrProcJud = nrProcJud
    def get_codSusp(self): return self.codSusp
    def set_codSusp(self, codSusp): self.codSusp = codSusp
    def hasContent_(self):
        if (
            self.tpTrib is not None or
            self.nrProcJud is not None or
            self.codSusp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='procJudTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procJudTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='procJudTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='procJudTrab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='procJudTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procJudTrab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpTrib>%s</%stpTrib>%s' % (namespace_, self.gds_format_integer(self.tpTrib, input_name='tpTrib'), namespace_, eol_))
        if self.nrProcJud is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrProcJud>%s</%snrProcJud>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrProcJud), input_name='nrProcJud')), namespace_, eol_))
        if self.codSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodSusp>%s</%scodSusp>%s' % (namespace_, self.gds_format_integer(self.codSusp, input_name='codSusp'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpTrib':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpTrib')
            self.tpTrib = ival_
        elif nodeName_ == 'nrProcJud':
            nrProcJud_ = child_.text
            nrProcJud_ = self.gds_validate_string(nrProcJud_, node, 'nrProcJud')
            self.nrProcJud = nrProcJud_
        elif nodeName_ == 'codSusp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codSusp')
            self.codSusp = ival_
# end class procJudTrab


class tpTrib(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpTrib)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpTrib.subclass:
            return tpTrib.subclass(*args_, **kwargs_)
        else:
            return tpTrib(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpTrib', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpTrib')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpTrib')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpTrib', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpTrib'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpTrib', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpTrib


class nrProcJud(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrProcJud)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrProcJud.subclass:
            return nrProcJud.subclass(*args_, **kwargs_)
        else:
            return nrProcJud(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrProcJud', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrProcJud')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrProcJud')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrProcJud', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrProcJud'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrProcJud', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrProcJud


class codSusp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codSusp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codSusp.subclass:
            return codSusp.subclass(*args_, **kwargs_)
        else:
            return codSusp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codSusp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codSusp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codSusp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codSusp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codSusp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codSusp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codSusp


class infoMV(GeneratedsSuper):
    """Registro preenchido exclusivamente em caso de trabalhador que possua
    outros vínculos/atividades nos quais já tenha ocorrido desconto
    de contribuição previdenciária."""
    subclass = None
    superclass = None
    def __init__(self, indMV=None, remunOutrEmpr=None):
        self.original_tagname_ = None
        self.indMV = indMV
        if remunOutrEmpr is None:
            self.remunOutrEmpr = []
        else:
            self.remunOutrEmpr = remunOutrEmpr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoMV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoMV.subclass:
            return infoMV.subclass(*args_, **kwargs_)
        else:
            return infoMV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indMV(self): return self.indMV
    def set_indMV(self, indMV): self.indMV = indMV
    def get_remunOutrEmpr(self): return self.remunOutrEmpr
    def set_remunOutrEmpr(self, remunOutrEmpr): self.remunOutrEmpr = remunOutrEmpr
    def add_remunOutrEmpr(self, value): self.remunOutrEmpr.append(value)
    def insert_remunOutrEmpr_at(self, index, value): self.remunOutrEmpr.insert(index, value)
    def replace_remunOutrEmpr_at(self, index, value): self.remunOutrEmpr[index] = value
    def hasContent_(self):
        if (
            self.indMV is not None or
            self.remunOutrEmpr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoMV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoMV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoMV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoMV', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoMV'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoMV', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indMV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindMV>%s</%sindMV>%s' % (namespace_, self.gds_format_integer(self.indMV, input_name='indMV'), namespace_, eol_))
        for remunOutrEmpr_ in self.remunOutrEmpr:
            remunOutrEmpr_.export(outfile, level, namespace_, name_='remunOutrEmpr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indMV':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indMV')
            self.indMV = ival_
        elif nodeName_ == 'remunOutrEmpr':
            obj_ = TRemunOutrasEmpresas.factory()
            obj_.build(child_)
            self.remunOutrEmpr.append(obj_)
            obj_.original_tagname_ = 'remunOutrEmpr'
# end class infoMV


class indMV(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indMV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indMV.subclass:
            return indMV.subclass(*args_, **kwargs_)
        else:
            return indMV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indMV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indMV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indMV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indMV', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indMV'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indMV', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indMV


class quarentena(GeneratedsSuper):
    """Informações sobre a 'quarentena' remunerada de trabalhador
    desligado. O registro deve ser preenchido apenas no caso do
    trabalhador que recebe remuneração após o desligamento por estar
    impossibilitado de exercer atividade remunerada."""
    subclass = None
    superclass = None
    def __init__(self, dtFimQuar=None):
        self.original_tagname_ = None
        if isinstance(dtFimQuar, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dtFimQuar, '%Y-%m-%d').date()
        else:
            initvalue_ = dtFimQuar
        self.dtFimQuar = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quarentena)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quarentena.subclass:
            return quarentena.subclass(*args_, **kwargs_)
        else:
            return quarentena(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dtFimQuar(self): return self.dtFimQuar
    def set_dtFimQuar(self, dtFimQuar): self.dtFimQuar = dtFimQuar
    def hasContent_(self):
        if (
            self.dtFimQuar is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='quarentena', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quarentena')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='quarentena')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='quarentena', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='quarentena'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='quarentena', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dtFimQuar is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdtFimQuar>%s</%sdtFimQuar>%s' % (namespace_, self.gds_format_date(self.dtFimQuar, input_name='dtFimQuar'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dtFimQuar':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dtFimQuar = dval_
# end class quarentena


class dtFimQuar(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dtFimQuar)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dtFimQuar.subclass:
            return dtFimQuar.subclass(*args_, **kwargs_)
        else:
            return dtFimQuar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dtFimQuar', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dtFimQuar')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dtFimQuar')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dtFimQuar', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dtFimQuar'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dtFimQuar', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dtFimQuar


class TIdeEveTrab(GeneratedsSuper):
    """Identificação do evento"""
    subclass = None
    superclass = None
    def __init__(self, indRetif=None, nrRecibo=None, tpAmb=None, procEmi=None, verProc=None):
        self.original_tagname_ = None
        self.indRetif = indRetif
        self.nrRecibo = nrRecibo
        self.tpAmb = tpAmb
        self.procEmi = procEmi
        self.verProc = verProc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TIdeEveTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TIdeEveTrab.subclass:
            return TIdeEveTrab.subclass(*args_, **kwargs_)
        else:
            return TIdeEveTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indRetif(self): return self.indRetif
    def set_indRetif(self, indRetif): self.indRetif = indRetif
    def get_nrRecibo(self): return self.nrRecibo
    def set_nrRecibo(self, nrRecibo): self.nrRecibo = nrRecibo
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_procEmi(self): return self.procEmi
    def set_procEmi(self, procEmi): self.procEmi = procEmi
    def get_verProc(self): return self.verProc
    def set_verProc(self, verProc): self.verProc = verProc
    def hasContent_(self):
        if (
            self.indRetif is not None or
            self.nrRecibo is not None or
            self.tpAmb is not None or
            self.procEmi is not None or
            self.verProc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TIdeEveTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TIdeEveTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TIdeEveTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TIdeEveTrab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TIdeEveTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TIdeEveTrab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indRetif is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindRetif>%s</%sindRetif>%s' % (namespace_, self.gds_format_integer(self.indRetif, input_name='indRetif'), namespace_, eol_))
        if self.nrRecibo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrRecibo>%s</%snrRecibo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrRecibo), input_name='nrRecibo')), namespace_, eol_))
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespace_, self.gds_format_integer(self.tpAmb, input_name='tpAmb'), namespace_, eol_))
        if self.procEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocEmi>%s</%sprocEmi>%s' % (namespace_, self.gds_format_integer(self.procEmi, input_name='procEmi'), namespace_, eol_))
        if self.verProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverProc>%s</%sverProc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.verProc), input_name='verProc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indRetif':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indRetif')
            self.indRetif = ival_
        elif nodeName_ == 'nrRecibo':
            nrRecibo_ = child_.text
            nrRecibo_ = self.gds_validate_string(nrRecibo_, node, 'nrRecibo')
            self.nrRecibo = nrRecibo_
        elif nodeName_ == 'tpAmb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpAmb')
            self.tpAmb = ival_
        elif nodeName_ == 'procEmi':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'procEmi')
            self.procEmi = ival_
        elif nodeName_ == 'verProc':
            verProc_ = child_.text
            verProc_ = self.gds_validate_string(verProc_, node, 'verProc')
            self.verProc = verProc_
# end class TIdeEveTrab


class indRetif(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indRetif)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indRetif.subclass:
            return indRetif.subclass(*args_, **kwargs_)
        else:
            return indRetif(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indRetif', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indRetif')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indRetif')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indRetif', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indRetif'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indRetif', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indRetif


class nrRecibo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrRecibo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrRecibo.subclass:
            return nrRecibo.subclass(*args_, **kwargs_)
        else:
            return nrRecibo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrRecibo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrRecibo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrRecibo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrRecibo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrRecibo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrRecibo', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrRecibo


class tpAmb(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpAmb)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpAmb.subclass:
            return tpAmb.subclass(*args_, **kwargs_)
        else:
            return tpAmb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpAmb', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpAmb')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpAmb')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpAmb', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpAmb'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpAmb', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpAmb


class procEmi(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procEmi.subclass:
            return procEmi.subclass(*args_, **kwargs_)
        else:
            return procEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='procEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='procEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='procEmi', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='procEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procEmi', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class procEmi


class verProc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, verProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if verProc.subclass:
            return verProc.subclass(*args_, **kwargs_)
        else:
            return verProc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='verProc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('verProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='verProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='verProc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='verProc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='verProc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class verProc


class TEmpregador(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEmpregador)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEmpregador.subclass:
            return TEmpregador.subclass(*args_, **kwargs_)
        else:
            return TEmpregador(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEmpregador', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEmpregador')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEmpregador')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEmpregador', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEmpregador'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEmpregador', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
# end class TEmpregador


class TSaudeCol(GeneratedsSuper):
    """Planos de saúde coletivo"""
    subclass = None
    superclass = None
    def __init__(self, detOper=None):
        self.original_tagname_ = None
        if detOper is None:
            self.detOper = []
        else:
            self.detOper = detOper
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TSaudeCol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TSaudeCol.subclass:
            return TSaudeCol.subclass(*args_, **kwargs_)
        else:
            return TSaudeCol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_detOper(self): return self.detOper
    def set_detOper(self, detOper): self.detOper = detOper
    def add_detOper(self, value): self.detOper.append(value)
    def insert_detOper_at(self, index, value): self.detOper.insert(index, value)
    def replace_detOper_at(self, index, value): self.detOper[index] = value
    def hasContent_(self):
        if (
            self.detOper
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TSaudeCol', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TSaudeCol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TSaudeCol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TSaudeCol', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TSaudeCol'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TSaudeCol', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for detOper_ in self.detOper:
            detOper_.export(outfile, level, namespace_, name_='detOper', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'detOper':
            obj_ = detOper.factory()
            obj_.build(child_)
            self.detOper.append(obj_)
            obj_.original_tagname_ = 'detOper'
# end class TSaudeCol


class detOper(GeneratedsSuper):
    """Detalhamento dos valores pagos a Operadoras de Planos de Saúde."""
    subclass = None
    superclass = None
    def __init__(self, cnpjOper=None, regANS=None, vrPgTit=None, detPlano=None):
        self.original_tagname_ = None
        self.cnpjOper = cnpjOper
        self.regANS = regANS
        self.vrPgTit = vrPgTit
        if detPlano is None:
            self.detPlano = []
        else:
            self.detPlano = detPlano
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detOper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detOper.subclass:
            return detOper.subclass(*args_, **kwargs_)
        else:
            return detOper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnpjOper(self): return self.cnpjOper
    def set_cnpjOper(self, cnpjOper): self.cnpjOper = cnpjOper
    def get_regANS(self): return self.regANS
    def set_regANS(self, regANS): self.regANS = regANS
    def get_vrPgTit(self): return self.vrPgTit
    def set_vrPgTit(self, vrPgTit): self.vrPgTit = vrPgTit
    def get_detPlano(self): return self.detPlano
    def set_detPlano(self, detPlano): self.detPlano = detPlano
    def add_detPlano(self, value): self.detPlano.append(value)
    def insert_detPlano_at(self, index, value): self.detPlano.insert(index, value)
    def replace_detPlano_at(self, index, value): self.detPlano[index] = value
    def hasContent_(self):
        if (
            self.cnpjOper is not None or
            self.regANS is not None or
            self.vrPgTit is not None or
            self.detPlano
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detOper', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detOper')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detOper')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detOper', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detOper'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='detOper', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnpjOper is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scnpjOper>%s</%scnpjOper>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cnpjOper), input_name='cnpjOper')), namespace_, eol_))
        if self.regANS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregANS>%s</%sregANS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.regANS), input_name='regANS')), namespace_, eol_))
        if self.vrPgTit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrPgTit>%s</%svrPgTit>%s' % (namespace_, self.gds_format_float(self.vrPgTit, input_name='vrPgTit'), namespace_, eol_))
        for detPlano_ in self.detPlano:
            detPlano_.export(outfile, level, namespace_, name_='detPlano', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnpjOper':
            cnpjOper_ = child_.text
            cnpjOper_ = self.gds_validate_string(cnpjOper_, node, 'cnpjOper')
            self.cnpjOper = cnpjOper_
        elif nodeName_ == 'regANS':
            regANS_ = child_.text
            regANS_ = self.gds_validate_string(regANS_, node, 'regANS')
            self.regANS = regANS_
        elif nodeName_ == 'vrPgTit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrPgTit')
            self.vrPgTit = fval_
        elif nodeName_ == 'detPlano':
            obj_ = detPlano.factory()
            obj_.build(child_)
            self.detPlano.append(obj_)
            obj_.original_tagname_ = 'detPlano'
# end class detOper


class cnpjOper(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cnpjOper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cnpjOper.subclass:
            return cnpjOper.subclass(*args_, **kwargs_)
        else:
            return cnpjOper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cnpjOper', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cnpjOper')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cnpjOper')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cnpjOper', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cnpjOper'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cnpjOper', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cnpjOper


class regANS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, regANS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if regANS.subclass:
            return regANS.subclass(*args_, **kwargs_)
        else:
            return regANS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='regANS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('regANS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='regANS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='regANS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='regANS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='regANS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class regANS


class vrPgTit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrPgTit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrPgTit.subclass:
            return vrPgTit.subclass(*args_, **kwargs_)
        else:
            return vrPgTit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrPgTit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrPgTit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrPgTit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrPgTit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrPgTit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrPgTit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrPgTit


class detPlano(GeneratedsSuper):
    """Informações do dependente do plano privado de saúde."""
    subclass = None
    superclass = None
    def __init__(self, tpDep=None, cpfDep=None, nmDep=None, dtNascto=None, vlrPgDep=None):
        self.original_tagname_ = None
        self.tpDep = tpDep
        self.cpfDep = cpfDep
        self.nmDep = nmDep
        if isinstance(dtNascto, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dtNascto, '%Y-%m-%d').date()
        else:
            initvalue_ = dtNascto
        self.dtNascto = initvalue_
        self.vlrPgDep = vlrPgDep
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detPlano)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detPlano.subclass:
            return detPlano.subclass(*args_, **kwargs_)
        else:
            return detPlano(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpDep(self): return self.tpDep
    def set_tpDep(self, tpDep): self.tpDep = tpDep
    def get_cpfDep(self): return self.cpfDep
    def set_cpfDep(self, cpfDep): self.cpfDep = cpfDep
    def get_nmDep(self): return self.nmDep
    def set_nmDep(self, nmDep): self.nmDep = nmDep
    def get_dtNascto(self): return self.dtNascto
    def set_dtNascto(self, dtNascto): self.dtNascto = dtNascto
    def get_vlrPgDep(self): return self.vlrPgDep
    def set_vlrPgDep(self, vlrPgDep): self.vlrPgDep = vlrPgDep
    def hasContent_(self):
        if (
            self.tpDep is not None or
            self.cpfDep is not None or
            self.nmDep is not None or
            self.dtNascto is not None or
            self.vlrPgDep is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detPlano', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detPlano')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detPlano')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detPlano', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detPlano'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='detPlano', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpDep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpDep>%s</%stpDep>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpDep), input_name='tpDep')), namespace_, eol_))
        if self.cpfDep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpfDep>%s</%scpfDep>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cpfDep), input_name='cpfDep')), namespace_, eol_))
        if self.nmDep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snmDep>%s</%snmDep>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nmDep), input_name='nmDep')), namespace_, eol_))
        if self.dtNascto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdtNascto>%s</%sdtNascto>%s' % (namespace_, self.gds_format_date(self.dtNascto, input_name='dtNascto'), namespace_, eol_))
        if self.vlrPgDep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svlrPgDep>%s</%svlrPgDep>%s' % (namespace_, self.gds_format_float(self.vlrPgDep, input_name='vlrPgDep'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpDep':
            tpDep_ = child_.text
            tpDep_ = self.gds_validate_string(tpDep_, node, 'tpDep')
            self.tpDep = tpDep_
        elif nodeName_ == 'cpfDep':
            cpfDep_ = child_.text
            cpfDep_ = self.gds_validate_string(cpfDep_, node, 'cpfDep')
            self.cpfDep = cpfDep_
        elif nodeName_ == 'nmDep':
            nmDep_ = child_.text
            nmDep_ = self.gds_validate_string(nmDep_, node, 'nmDep')
            self.nmDep = nmDep_
        elif nodeName_ == 'dtNascto':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dtNascto = dval_
        elif nodeName_ == 'vlrPgDep':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vlrPgDep')
            self.vlrPgDep = fval_
# end class detPlano


class tpDep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpDep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpDep.subclass:
            return tpDep.subclass(*args_, **kwargs_)
        else:
            return tpDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpDep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpDep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpDep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpDep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpDep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpDep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpDep


class cpfDep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cpfDep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cpfDep.subclass:
            return cpfDep.subclass(*args_, **kwargs_)
        else:
            return cpfDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cpfDep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpfDep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cpfDep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cpfDep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cpfDep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cpfDep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cpfDep


class nmDep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nmDep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nmDep.subclass:
            return nmDep.subclass(*args_, **kwargs_)
        else:
            return nmDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nmDep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nmDep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nmDep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nmDep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nmDep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nmDep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nmDep


class dtNascto(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dtNascto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dtNascto.subclass:
            return dtNascto.subclass(*args_, **kwargs_)
        else:
            return dtNascto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dtNascto', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dtNascto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dtNascto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dtNascto', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dtNascto'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dtNascto', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dtNascto


class vlrPgDep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vlrPgDep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vlrPgDep.subclass:
            return vlrPgDep.subclass(*args_, **kwargs_)
        else:
            return vlrPgDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vlrPgDep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vlrPgDep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vlrPgDep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vlrPgDep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vlrPgDep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vlrPgDep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vlrPgDep


class TRemunOutrasEmpresas(GeneratedsSuper):
    """Registro que complementa as informações relativas ao trabalhador que
    possui vínculo empregatício com outra(s) empresa(s) e/ou que
    exerce outras atividades como contribuinte individual,
    detalhando as empresas que efetuaram (ou efetuarão) desconto da
    contribuição, ou ainda valores recolhidos pelo próprio
    trabalhador como contribuinte individual. As informações
    prestadas são necessárias para a conferência da contribuição
    descontada do segurado."""
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None, codCateg=None, vlrRemunOE=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
        self.codCateg = codCateg
        self.vlrRemunOE = vlrRemunOE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRemunOutrasEmpresas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRemunOutrasEmpresas.subclass:
            return TRemunOutrasEmpresas.subclass(*args_, **kwargs_)
        else:
            return TRemunOutrasEmpresas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def get_codCateg(self): return self.codCateg
    def set_codCateg(self, codCateg): self.codCateg = codCateg
    def get_vlrRemunOE(self): return self.vlrRemunOE
    def set_vlrRemunOE(self, vlrRemunOE): self.vlrRemunOE = vlrRemunOE
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None or
            self.codCateg is not None or
            self.vlrRemunOE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TRemunOutrasEmpresas', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRemunOutrasEmpresas')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TRemunOutrasEmpresas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TRemunOutrasEmpresas', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TRemunOutrasEmpresas'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TRemunOutrasEmpresas', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
        if self.codCateg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodCateg>%s</%scodCateg>%s' % (namespace_, self.gds_format_integer(self.codCateg, input_name='codCateg'), namespace_, eol_))
        if self.vlrRemunOE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svlrRemunOE>%s</%svlrRemunOE>%s' % (namespace_, self.gds_format_float(self.vlrRemunOE, input_name='vlrRemunOE'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
        elif nodeName_ == 'codCateg':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codCateg')
            self.codCateg = ival_
        elif nodeName_ == 'vlrRemunOE':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vlrRemunOE')
            self.vlrRemunOE = fval_
# end class TRemunOutrasEmpresas


class vlrRemunOE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vlrRemunOE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vlrRemunOE.subclass:
            return vlrRemunOE.subclass(*args_, **kwargs_)
        else:
            return vlrRemunOE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vlrRemunOE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vlrRemunOE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vlrRemunOE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vlrRemunOE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vlrRemunOE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vlrRemunOE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vlrRemunOE


GDSClassesMapping = {
    'ideEmpregador': TEmpregador,
    'ideEvento': TIdeEveTrab,
    'infoSaudeColet': TSaudeCol,
    'remunOutrEmpr': TRemunOutrasEmpresas,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from evtTSVTermino import *\n\n')
        sys.stdout.write('import evtTSVTermino as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "TEmpregador",
    "TIdeEveTrab",
    "TRemunOutrasEmpresas",
    "TSaudeCol",
    "eSocial"
]
