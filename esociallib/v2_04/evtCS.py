#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Oct 10 00:42:22 2017 by generateDS.py version 2.28b.
# Python 2.7.12 (default, Nov 19 2016, 06:48:10)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('--no-process-includes', '')
#   ('-o', 'esociallib/v2_04/evtCS.py')
#
# Command line arguments:
#   schemas/v2_04/evtCS.xsd
#
# Command line:
#   /usr/local/bin/generateDS --no-process-includes -o "esociallib/v2_04/evtCS.py" schemas/v2_04/evtCS.xsd
#
# Current working directory (os.getcwd()):
#   esociallib
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class eSocial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evtCS=None, Signature=None):
        self.original_tagname_ = None
        self.evtCS = evtCS
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eSocial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eSocial.subclass:
            return eSocial.subclass(*args_, **kwargs_)
        else:
            return eSocial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evtCS(self): return self.evtCS
    def set_evtCS(self, evtCS): self.evtCS = evtCS
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def hasContent_(self):
        if (
            self.evtCS is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eSocial', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eSocial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eSocial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eSocial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eSocial'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='eSocial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.evtCS is not None:
            self.evtCS.export(outfile, level, namespace_, name_='evtCS', pretty_print=pretty_print)
        if self.Signature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSignature>%s</%sSignature>%s' % ('ds:', self.gds_encode(self.gds_format_string(quote_xml(self.Signature), input_name='Signature')), 'ds:', eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'evtCS':
            obj_ = evtCS.factory()
            obj_.build(child_)
            self.evtCS = obj_
            obj_.original_tagname_ = 'evtCS'
        elif nodeName_ == 'Signature':
            Signature_ = child_.text
            Signature_ = self.gds_validate_string(Signature_, node, 'Signature')
            self.Signature = Signature_
# end class eSocial


class evtCS(GeneratedsSuper):
    """Evento demonstrativo das Contribuições Sociais devidas à Previdência
    Social e a Outras Entidades e Fundos e das suas bases de
    cálculo."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, ideEvento=None, ideEmpregador=None, infoCS=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.ideEvento = ideEvento
        self.ideEmpregador = ideEmpregador
        self.infoCS = infoCS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, evtCS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if evtCS.subclass:
            return evtCS.subclass(*args_, **kwargs_)
        else:
            return evtCS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideEvento(self): return self.ideEvento
    def set_ideEvento(self, ideEvento): self.ideEvento = ideEvento
    def get_ideEmpregador(self): return self.ideEmpregador
    def set_ideEmpregador(self, ideEmpregador): self.ideEmpregador = ideEmpregador
    def get_infoCS(self): return self.infoCS
    def set_infoCS(self, infoCS): self.infoCS = infoCS
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.ideEvento is not None or
            self.ideEmpregador is not None or
            self.infoCS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='evtCS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('evtCS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='evtCS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='evtCS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='evtCS'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='evtCS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideEvento is not None:
            self.ideEvento.export(outfile, level, namespace_, name_='ideEvento', pretty_print=pretty_print)
        if self.ideEmpregador is not None:
            self.ideEmpregador.export(outfile, level, namespace_, name_='ideEmpregador', pretty_print=pretty_print)
        if self.infoCS is not None:
            self.infoCS.export(outfile, level, namespace_, name_='infoCS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideEvento':
            obj_ = ideEvento.factory()
            obj_.build(child_)
            self.ideEvento = obj_
            obj_.original_tagname_ = 'ideEvento'
        elif nodeName_ == 'ideEmpregador':
            obj_ = TEmpregador.factory()
            obj_.build(child_)
            self.ideEmpregador = obj_
            obj_.original_tagname_ = 'ideEmpregador'
        elif nodeName_ == 'infoCS':
            obj_ = infoCS.factory()
            obj_.build(child_)
            self.infoCS = obj_
            obj_.original_tagname_ = 'infoCS'
# end class evtCS


class ideEvento(GeneratedsSuper):
    """Identificação do evento de retorno"""
    subclass = None
    superclass = None
    def __init__(self, indApuracao=None, perApur=None):
        self.original_tagname_ = None
        self.indApuracao = indApuracao
        self.perApur = perApur
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideEvento)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideEvento.subclass:
            return ideEvento.subclass(*args_, **kwargs_)
        else:
            return ideEvento(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indApuracao(self): return self.indApuracao
    def set_indApuracao(self, indApuracao): self.indApuracao = indApuracao
    def get_perApur(self): return self.perApur
    def set_perApur(self, perApur): self.perApur = perApur
    def hasContent_(self):
        if (
            self.indApuracao is not None or
            self.perApur is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideEvento', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideEvento')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideEvento')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideEvento', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideEvento'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideEvento', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indApuracao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindApuracao>%s</%sindApuracao>%s' % (namespace_, self.gds_format_integer(self.indApuracao, input_name='indApuracao'), namespace_, eol_))
        if self.perApur is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sperApur>%s</%sperApur>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.perApur), input_name='perApur')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indApuracao':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indApuracao')
            self.indApuracao = ival_
        elif nodeName_ == 'perApur':
            perApur_ = child_.text
            perApur_ = self.gds_validate_string(perApur_, node, 'perApur')
            self.perApur = perApur_
# end class ideEvento


class indApuracao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indApuracao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indApuracao.subclass:
            return indApuracao.subclass(*args_, **kwargs_)
        else:
            return indApuracao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indApuracao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indApuracao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indApuracao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indApuracao', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indApuracao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indApuracao', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indApuracao


class perApur(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, perApur)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if perApur.subclass:
            return perApur.subclass(*args_, **kwargs_)
        else:
            return perApur(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='perApur', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('perApur')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='perApur')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='perApur', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='perApur'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='perApur', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class perApur


class infoCS(GeneratedsSuper):
    """Informações relativas às Contribuições Sociais devidas à Previdência
    Social e a Outras Entidades e Fundos."""
    subclass = None
    superclass = None
    def __init__(self, nrRecArqBase=None, indExistInfo=None, infoCPSeg=None, infoContrib=None, ideEstab=None, infoCRContrib=None):
        self.original_tagname_ = None
        self.nrRecArqBase = nrRecArqBase
        self.indExistInfo = indExistInfo
        self.infoCPSeg = infoCPSeg
        self.infoContrib = infoContrib
        if ideEstab is None:
            self.ideEstab = []
        else:
            self.ideEstab = ideEstab
        if infoCRContrib is None:
            self.infoCRContrib = []
        else:
            self.infoCRContrib = infoCRContrib
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoCS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoCS.subclass:
            return infoCS.subclass(*args_, **kwargs_)
        else:
            return infoCS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nrRecArqBase(self): return self.nrRecArqBase
    def set_nrRecArqBase(self, nrRecArqBase): self.nrRecArqBase = nrRecArqBase
    def get_indExistInfo(self): return self.indExistInfo
    def set_indExistInfo(self, indExistInfo): self.indExistInfo = indExistInfo
    def get_infoCPSeg(self): return self.infoCPSeg
    def set_infoCPSeg(self, infoCPSeg): self.infoCPSeg = infoCPSeg
    def get_infoContrib(self): return self.infoContrib
    def set_infoContrib(self, infoContrib): self.infoContrib = infoContrib
    def get_ideEstab(self): return self.ideEstab
    def set_ideEstab(self, ideEstab): self.ideEstab = ideEstab
    def add_ideEstab(self, value): self.ideEstab.append(value)
    def insert_ideEstab_at(self, index, value): self.ideEstab.insert(index, value)
    def replace_ideEstab_at(self, index, value): self.ideEstab[index] = value
    def get_infoCRContrib(self): return self.infoCRContrib
    def set_infoCRContrib(self, infoCRContrib): self.infoCRContrib = infoCRContrib
    def add_infoCRContrib(self, value): self.infoCRContrib.append(value)
    def insert_infoCRContrib_at(self, index, value): self.infoCRContrib.insert(index, value)
    def replace_infoCRContrib_at(self, index, value): self.infoCRContrib[index] = value
    def hasContent_(self):
        if (
            self.nrRecArqBase is not None or
            self.indExistInfo is not None or
            self.infoCPSeg is not None or
            self.infoContrib is not None or
            self.ideEstab or
            self.infoCRContrib
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoCS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoCS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoCS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoCS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoCS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoCS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nrRecArqBase is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrRecArqBase>%s</%snrRecArqBase>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrRecArqBase), input_name='nrRecArqBase')), namespace_, eol_))
        if self.indExistInfo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindExistInfo>%s</%sindExistInfo>%s' % (namespace_, self.gds_format_integer(self.indExistInfo, input_name='indExistInfo'), namespace_, eol_))
        if self.infoCPSeg is not None:
            self.infoCPSeg.export(outfile, level, namespace_, name_='infoCPSeg', pretty_print=pretty_print)
        if self.infoContrib is not None:
            self.infoContrib.export(outfile, level, namespace_, name_='infoContrib', pretty_print=pretty_print)
        for ideEstab_ in self.ideEstab:
            ideEstab_.export(outfile, level, namespace_, name_='ideEstab', pretty_print=pretty_print)
        for infoCRContrib_ in self.infoCRContrib:
            infoCRContrib_.export(outfile, level, namespace_, name_='infoCRContrib', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nrRecArqBase':
            nrRecArqBase_ = child_.text
            nrRecArqBase_ = self.gds_validate_string(nrRecArqBase_, node, 'nrRecArqBase')
            self.nrRecArqBase = nrRecArqBase_
        elif nodeName_ == 'indExistInfo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indExistInfo')
            self.indExistInfo = ival_
        elif nodeName_ == 'infoCPSeg':
            obj_ = infoCPSeg.factory()
            obj_.build(child_)
            self.infoCPSeg = obj_
            obj_.original_tagname_ = 'infoCPSeg'
        elif nodeName_ == 'infoContrib':
            obj_ = infoContrib.factory()
            obj_.build(child_)
            self.infoContrib = obj_
            obj_.original_tagname_ = 'infoContrib'
        elif nodeName_ == 'ideEstab':
            obj_ = ideEstab.factory()
            obj_.build(child_)
            self.ideEstab.append(obj_)
            obj_.original_tagname_ = 'ideEstab'
        elif nodeName_ == 'infoCRContrib':
            obj_ = infoCRContrib.factory()
            obj_.build(child_)
            self.infoCRContrib.append(obj_)
            obj_.original_tagname_ = 'infoCRContrib'
# end class infoCS


class nrRecArqBase(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrRecArqBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrRecArqBase.subclass:
            return nrRecArqBase.subclass(*args_, **kwargs_)
        else:
            return nrRecArqBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrRecArqBase', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrRecArqBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrRecArqBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrRecArqBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrRecArqBase'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrRecArqBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrRecArqBase


class indExistInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indExistInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indExistInfo.subclass:
            return indExistInfo.subclass(*args_, **kwargs_)
        else:
            return indExistInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indExistInfo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indExistInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indExistInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indExistInfo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indExistInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indExistInfo', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indExistInfo


class infoCPSeg(GeneratedsSuper):
    """Informações de contribuição previdenciária do Segurado"""
    subclass = None
    superclass = None
    def __init__(self, vrDescCP=None, vrCpSeg=None):
        self.original_tagname_ = None
        self.vrDescCP = vrDescCP
        self.vrCpSeg = vrCpSeg
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoCPSeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoCPSeg.subclass:
            return infoCPSeg.subclass(*args_, **kwargs_)
        else:
            return infoCPSeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vrDescCP(self): return self.vrDescCP
    def set_vrDescCP(self, vrDescCP): self.vrDescCP = vrDescCP
    def get_vrCpSeg(self): return self.vrCpSeg
    def set_vrCpSeg(self, vrCpSeg): self.vrCpSeg = vrCpSeg
    def hasContent_(self):
        if (
            self.vrDescCP is not None or
            self.vrCpSeg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoCPSeg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoCPSeg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoCPSeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoCPSeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoCPSeg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoCPSeg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vrDescCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrDescCP>%s</%svrDescCP>%s' % (namespace_, self.gds_format_float(self.vrDescCP, input_name='vrDescCP'), namespace_, eol_))
        if self.vrCpSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCpSeg>%s</%svrCpSeg>%s' % (namespace_, self.gds_format_float(self.vrCpSeg, input_name='vrCpSeg'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vrDescCP':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrDescCP')
            self.vrDescCP = fval_
        elif nodeName_ == 'vrCpSeg':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCpSeg')
            self.vrCpSeg = fval_
# end class infoCPSeg


class vrDescCP(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrDescCP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrDescCP.subclass:
            return vrDescCP.subclass(*args_, **kwargs_)
        else:
            return vrDescCP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrDescCP', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrDescCP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrDescCP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrDescCP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrDescCP'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrDescCP', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrDescCP


class vrCpSeg(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrCpSeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrCpSeg.subclass:
            return vrCpSeg.subclass(*args_, **kwargs_)
        else:
            return vrCpSeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrCpSeg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrCpSeg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrCpSeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrCpSeg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrCpSeg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrCpSeg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrCpSeg


class infoContrib(GeneratedsSuper):
    """Informações gerais do contribuinte necessárias à apuração das
    contribuições sociais."""
    subclass = None
    superclass = None
    def __init__(self, classTrib=None, infoPJ=None):
        self.original_tagname_ = None
        self.classTrib = classTrib
        self.infoPJ = infoPJ
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoContrib)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoContrib.subclass:
            return infoContrib.subclass(*args_, **kwargs_)
        else:
            return infoContrib(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_classTrib(self): return self.classTrib
    def set_classTrib(self, classTrib): self.classTrib = classTrib
    def get_infoPJ(self): return self.infoPJ
    def set_infoPJ(self, infoPJ): self.infoPJ = infoPJ
    def hasContent_(self):
        if (
            self.classTrib is not None or
            self.infoPJ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoContrib', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoContrib')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoContrib')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoContrib', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoContrib'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoContrib', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.classTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclassTrib>%s</%sclassTrib>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.classTrib), input_name='classTrib')), namespace_, eol_))
        if self.infoPJ is not None:
            self.infoPJ.export(outfile, level, namespace_, name_='infoPJ', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'classTrib':
            classTrib_ = child_.text
            classTrib_ = self.gds_validate_string(classTrib_, node, 'classTrib')
            self.classTrib = classTrib_
        elif nodeName_ == 'infoPJ':
            obj_ = infoPJ.factory()
            obj_.build(child_)
            self.infoPJ = obj_
            obj_.original_tagname_ = 'infoPJ'
# end class infoContrib


class classTrib(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, classTrib)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if classTrib.subclass:
            return classTrib.subclass(*args_, **kwargs_)
        else:
            return classTrib(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='classTrib', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('classTrib')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='classTrib')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='classTrib', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='classTrib'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='classTrib', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class classTrib


class infoPJ(GeneratedsSuper):
    """Informações complementares, exclusivas da Pessoa Jurídica."""
    subclass = None
    superclass = None
    def __init__(self, indCoop=None, indConstr=None, indSubstPatr=None, percRedContrib=None, infoAtConc=None):
        self.original_tagname_ = None
        self.indCoop = indCoop
        self.indConstr = indConstr
        self.indSubstPatr = indSubstPatr
        self.percRedContrib = percRedContrib
        self.infoAtConc = infoAtConc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoPJ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoPJ.subclass:
            return infoPJ.subclass(*args_, **kwargs_)
        else:
            return infoPJ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indCoop(self): return self.indCoop
    def set_indCoop(self, indCoop): self.indCoop = indCoop
    def get_indConstr(self): return self.indConstr
    def set_indConstr(self, indConstr): self.indConstr = indConstr
    def get_indSubstPatr(self): return self.indSubstPatr
    def set_indSubstPatr(self, indSubstPatr): self.indSubstPatr = indSubstPatr
    def get_percRedContrib(self): return self.percRedContrib
    def set_percRedContrib(self, percRedContrib): self.percRedContrib = percRedContrib
    def get_infoAtConc(self): return self.infoAtConc
    def set_infoAtConc(self, infoAtConc): self.infoAtConc = infoAtConc
    def hasContent_(self):
        if (
            self.indCoop is not None or
            self.indConstr is not None or
            self.indSubstPatr is not None or
            self.percRedContrib is not None or
            self.infoAtConc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoPJ', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoPJ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoPJ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoPJ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoPJ'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoPJ', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indCoop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindCoop>%s</%sindCoop>%s' % (namespace_, self.gds_format_integer(self.indCoop, input_name='indCoop'), namespace_, eol_))
        if self.indConstr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindConstr>%s</%sindConstr>%s' % (namespace_, self.gds_format_integer(self.indConstr, input_name='indConstr'), namespace_, eol_))
        if self.indSubstPatr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSubstPatr>%s</%sindSubstPatr>%s' % (namespace_, self.gds_format_integer(self.indSubstPatr, input_name='indSubstPatr'), namespace_, eol_))
        if self.percRedContrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spercRedContrib>%s</%spercRedContrib>%s' % (namespace_, self.gds_format_float(self.percRedContrib, input_name='percRedContrib'), namespace_, eol_))
        if self.infoAtConc is not None:
            self.infoAtConc.export(outfile, level, namespace_, name_='infoAtConc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indCoop':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indCoop')
            self.indCoop = ival_
        elif nodeName_ == 'indConstr':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indConstr')
            self.indConstr = ival_
        elif nodeName_ == 'indSubstPatr':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indSubstPatr')
            self.indSubstPatr = ival_
        elif nodeName_ == 'percRedContrib':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'percRedContrib')
            self.percRedContrib = fval_
        elif nodeName_ == 'infoAtConc':
            obj_ = infoAtConc.factory()
            obj_.build(child_)
            self.infoAtConc = obj_
            obj_.original_tagname_ = 'infoAtConc'
# end class infoPJ


class indCoop(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indCoop)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indCoop.subclass:
            return indCoop.subclass(*args_, **kwargs_)
        else:
            return indCoop(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indCoop', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indCoop')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indCoop')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indCoop', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indCoop'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indCoop', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indCoop


class indConstr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indConstr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indConstr.subclass:
            return indConstr.subclass(*args_, **kwargs_)
        else:
            return indConstr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indConstr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indConstr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indConstr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indConstr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indConstr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indConstr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indConstr


class indSubstPatr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indSubstPatr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indSubstPatr.subclass:
            return indSubstPatr.subclass(*args_, **kwargs_)
        else:
            return indSubstPatr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indSubstPatr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indSubstPatr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indSubstPatr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indSubstPatr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indSubstPatr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indSubstPatr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indSubstPatr


class percRedContrib(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, percRedContrib)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if percRedContrib.subclass:
            return percRedContrib.subclass(*args_, **kwargs_)
        else:
            return percRedContrib(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='percRedContrib', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('percRedContrib')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='percRedContrib')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='percRedContrib', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='percRedContrib'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='percRedContrib', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class percRedContrib


class infoAtConc(GeneratedsSuper):
    """Informações prestadas por empresa enquadrada no Regime de Tributação
    Simples Nacional com tributação previdenciária substituída e não
    substituída."""
    subclass = None
    superclass = None
    def __init__(self, fatorMes=None, fator13=None):
        self.original_tagname_ = None
        self.fatorMes = fatorMes
        self.fator13 = fator13
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoAtConc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoAtConc.subclass:
            return infoAtConc.subclass(*args_, **kwargs_)
        else:
            return infoAtConc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fatorMes(self): return self.fatorMes
    def set_fatorMes(self, fatorMes): self.fatorMes = fatorMes
    def get_fator13(self): return self.fator13
    def set_fator13(self, fator13): self.fator13 = fator13
    def hasContent_(self):
        if (
            self.fatorMes is not None or
            self.fator13 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoAtConc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoAtConc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoAtConc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoAtConc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoAtConc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoAtConc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fatorMes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfatorMes>%s</%sfatorMes>%s' % (namespace_, self.gds_format_float(self.fatorMes, input_name='fatorMes'), namespace_, eol_))
        if self.fator13 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfator13>%s</%sfator13>%s' % (namespace_, self.gds_format_float(self.fator13, input_name='fator13'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fatorMes':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fatorMes')
            self.fatorMes = fval_
        elif nodeName_ == 'fator13':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fator13')
            self.fator13 = fval_
# end class infoAtConc


class fatorMes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fatorMes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fatorMes.subclass:
            return fatorMes.subclass(*args_, **kwargs_)
        else:
            return fatorMes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fatorMes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fatorMes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fatorMes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fatorMes', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fatorMes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fatorMes', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fatorMes


class fator13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fator13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fator13.subclass:
            return fator13.subclass(*args_, **kwargs_)
        else:
            return fator13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fator13', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fator13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fator13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fator13', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fator13'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fator13', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fator13


class ideEstab(GeneratedsSuper):
    """Informações de identificação do estabelecimento ou obra de
    construção civil."""
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None, infoEstab=None, ideLotacao=None, basesAquis=None, basesComerc=None, infoCREstab=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
        self.infoEstab = infoEstab
        if ideLotacao is None:
            self.ideLotacao = []
        else:
            self.ideLotacao = ideLotacao
        if basesAquis is None:
            self.basesAquis = []
        else:
            self.basesAquis = basesAquis
        if basesComerc is None:
            self.basesComerc = []
        else:
            self.basesComerc = basesComerc
        if infoCREstab is None:
            self.infoCREstab = []
        else:
            self.infoCREstab = infoCREstab
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideEstab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideEstab.subclass:
            return ideEstab.subclass(*args_, **kwargs_)
        else:
            return ideEstab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def get_infoEstab(self): return self.infoEstab
    def set_infoEstab(self, infoEstab): self.infoEstab = infoEstab
    def get_ideLotacao(self): return self.ideLotacao
    def set_ideLotacao(self, ideLotacao): self.ideLotacao = ideLotacao
    def add_ideLotacao(self, value): self.ideLotacao.append(value)
    def insert_ideLotacao_at(self, index, value): self.ideLotacao.insert(index, value)
    def replace_ideLotacao_at(self, index, value): self.ideLotacao[index] = value
    def get_basesAquis(self): return self.basesAquis
    def set_basesAquis(self, basesAquis): self.basesAquis = basesAquis
    def add_basesAquis(self, value): self.basesAquis.append(value)
    def insert_basesAquis_at(self, index, value): self.basesAquis.insert(index, value)
    def replace_basesAquis_at(self, index, value): self.basesAquis[index] = value
    def get_basesComerc(self): return self.basesComerc
    def set_basesComerc(self, basesComerc): self.basesComerc = basesComerc
    def add_basesComerc(self, value): self.basesComerc.append(value)
    def insert_basesComerc_at(self, index, value): self.basesComerc.insert(index, value)
    def replace_basesComerc_at(self, index, value): self.basesComerc[index] = value
    def get_infoCREstab(self): return self.infoCREstab
    def set_infoCREstab(self, infoCREstab): self.infoCREstab = infoCREstab
    def add_infoCREstab(self, value): self.infoCREstab.append(value)
    def insert_infoCREstab_at(self, index, value): self.infoCREstab.insert(index, value)
    def replace_infoCREstab_at(self, index, value): self.infoCREstab[index] = value
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None or
            self.infoEstab is not None or
            self.ideLotacao or
            self.basesAquis or
            self.basesComerc or
            self.infoCREstab
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideEstab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideEstab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideEstab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideEstab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideEstab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideEstab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
        if self.infoEstab is not None:
            self.infoEstab.export(outfile, level, namespace_, name_='infoEstab', pretty_print=pretty_print)
        for ideLotacao_ in self.ideLotacao:
            ideLotacao_.export(outfile, level, namespace_, name_='ideLotacao', pretty_print=pretty_print)
        for basesAquis_ in self.basesAquis:
            basesAquis_.export(outfile, level, namespace_, name_='basesAquis', pretty_print=pretty_print)
        for basesComerc_ in self.basesComerc:
            basesComerc_.export(outfile, level, namespace_, name_='basesComerc', pretty_print=pretty_print)
        for infoCREstab_ in self.infoCREstab:
            infoCREstab_.export(outfile, level, namespace_, name_='infoCREstab', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
        elif nodeName_ == 'infoEstab':
            obj_ = infoEstab.factory()
            obj_.build(child_)
            self.infoEstab = obj_
            obj_.original_tagname_ = 'infoEstab'
        elif nodeName_ == 'ideLotacao':
            obj_ = ideLotacao.factory()
            obj_.build(child_)
            self.ideLotacao.append(obj_)
            obj_.original_tagname_ = 'ideLotacao'
        elif nodeName_ == 'basesAquis':
            obj_ = basesAquis.factory()
            obj_.build(child_)
            self.basesAquis.append(obj_)
            obj_.original_tagname_ = 'basesAquis'
        elif nodeName_ == 'basesComerc':
            obj_ = basesComerc.factory()
            obj_.build(child_)
            self.basesComerc.append(obj_)
            obj_.original_tagname_ = 'basesComerc'
        elif nodeName_ == 'infoCREstab':
            obj_ = infoCREstab.factory()
            obj_.build(child_)
            self.infoCREstab.append(obj_)
            obj_.original_tagname_ = 'infoCREstab'
# end class ideEstab


class tpInsc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpInsc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpInsc.subclass:
            return tpInsc.subclass(*args_, **kwargs_)
        else:
            return tpInsc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpInsc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpInsc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpInsc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpInsc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpInsc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpInsc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpInsc


class nrInsc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrInsc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrInsc.subclass:
            return nrInsc.subclass(*args_, **kwargs_)
        else:
            return nrInsc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrInsc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrInsc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrInsc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrInsc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrInsc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrInsc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrInsc


class infoEstab(GeneratedsSuper):
    """Informações relativas a cada estabelecimento, necessárias à apuração
    das contribuições sociais."""
    subclass = None
    superclass = None
    def __init__(self, cnaePrep=None, aliqRat=None, fap=None, aliqRatAjust=None, infoComplObra=None):
        self.original_tagname_ = None
        self.cnaePrep = cnaePrep
        self.aliqRat = aliqRat
        self.fap = fap
        self.aliqRatAjust = aliqRatAjust
        self.infoComplObra = infoComplObra
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoEstab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoEstab.subclass:
            return infoEstab.subclass(*args_, **kwargs_)
        else:
            return infoEstab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnaePrep(self): return self.cnaePrep
    def set_cnaePrep(self, cnaePrep): self.cnaePrep = cnaePrep
    def get_aliqRat(self): return self.aliqRat
    def set_aliqRat(self, aliqRat): self.aliqRat = aliqRat
    def get_fap(self): return self.fap
    def set_fap(self, fap): self.fap = fap
    def get_aliqRatAjust(self): return self.aliqRatAjust
    def set_aliqRatAjust(self, aliqRatAjust): self.aliqRatAjust = aliqRatAjust
    def get_infoComplObra(self): return self.infoComplObra
    def set_infoComplObra(self, infoComplObra): self.infoComplObra = infoComplObra
    def hasContent_(self):
        if (
            self.cnaePrep is not None or
            self.aliqRat is not None or
            self.fap is not None or
            self.aliqRatAjust is not None or
            self.infoComplObra is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoEstab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoEstab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoEstab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoEstab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoEstab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoEstab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnaePrep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scnaePrep>%s</%scnaePrep>%s' % (namespace_, self.gds_format_integer(self.cnaePrep, input_name='cnaePrep'), namespace_, eol_))
        if self.aliqRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saliqRat>%s</%saliqRat>%s' % (namespace_, self.gds_format_integer(self.aliqRat, input_name='aliqRat'), namespace_, eol_))
        if self.fap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfap>%s</%sfap>%s' % (namespace_, self.gds_format_float(self.fap, input_name='fap'), namespace_, eol_))
        if self.aliqRatAjust is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saliqRatAjust>%s</%saliqRatAjust>%s' % (namespace_, self.gds_format_float(self.aliqRatAjust, input_name='aliqRatAjust'), namespace_, eol_))
        if self.infoComplObra is not None:
            self.infoComplObra.export(outfile, level, namespace_, name_='infoComplObra', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnaePrep':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cnaePrep')
            self.cnaePrep = ival_
        elif nodeName_ == 'aliqRat':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'aliqRat')
            self.aliqRat = ival_
        elif nodeName_ == 'fap':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fap')
            self.fap = fval_
        elif nodeName_ == 'aliqRatAjust':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'aliqRatAjust')
            self.aliqRatAjust = fval_
        elif nodeName_ == 'infoComplObra':
            obj_ = infoComplObra.factory()
            obj_.build(child_)
            self.infoComplObra = obj_
            obj_.original_tagname_ = 'infoComplObra'
# end class infoEstab


class cnaePrep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cnaePrep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cnaePrep.subclass:
            return cnaePrep.subclass(*args_, **kwargs_)
        else:
            return cnaePrep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cnaePrep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cnaePrep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cnaePrep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cnaePrep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cnaePrep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cnaePrep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cnaePrep


class aliqRat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, aliqRat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if aliqRat.subclass:
            return aliqRat.subclass(*args_, **kwargs_)
        else:
            return aliqRat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aliqRat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('aliqRat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aliqRat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='aliqRat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aliqRat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='aliqRat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class aliqRat


class fap(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fap.subclass:
            return fap.subclass(*args_, **kwargs_)
        else:
            return fap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fap', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fap', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fap'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fap', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fap


class aliqRatAjust(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, aliqRatAjust)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if aliqRatAjust.subclass:
            return aliqRatAjust.subclass(*args_, **kwargs_)
        else:
            return aliqRatAjust(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aliqRatAjust', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('aliqRatAjust')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aliqRatAjust')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='aliqRatAjust', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aliqRatAjust'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='aliqRatAjust', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class aliqRatAjust


class infoComplObra(GeneratedsSuper):
    """Informações complementares relativas a obras de construção civil"""
    subclass = None
    superclass = None
    def __init__(self, indSubstPatrObra=None):
        self.original_tagname_ = None
        self.indSubstPatrObra = indSubstPatrObra
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoComplObra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoComplObra.subclass:
            return infoComplObra.subclass(*args_, **kwargs_)
        else:
            return infoComplObra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indSubstPatrObra(self): return self.indSubstPatrObra
    def set_indSubstPatrObra(self, indSubstPatrObra): self.indSubstPatrObra = indSubstPatrObra
    def hasContent_(self):
        if (
            self.indSubstPatrObra is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoComplObra', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoComplObra')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoComplObra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoComplObra', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoComplObra'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoComplObra', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indSubstPatrObra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSubstPatrObra>%s</%sindSubstPatrObra>%s' % (namespace_, self.gds_format_integer(self.indSubstPatrObra, input_name='indSubstPatrObra'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indSubstPatrObra':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indSubstPatrObra')
            self.indSubstPatrObra = ival_
# end class infoComplObra


class indSubstPatrObra(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indSubstPatrObra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indSubstPatrObra.subclass:
            return indSubstPatrObra.subclass(*args_, **kwargs_)
        else:
            return indSubstPatrObra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indSubstPatrObra', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indSubstPatrObra')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indSubstPatrObra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indSubstPatrObra', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indSubstPatrObra'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indSubstPatrObra', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indSubstPatrObra


class ideLotacao(GeneratedsSuper):
    """Identificação da lotação tributária."""
    subclass = None
    superclass = None
    def __init__(self, codLotacao=None, fpas=None, codTercs=None, codTercsSusp=None, infoTercSusp=None, infoEmprParcial=None, dadosOpPort=None, basesRemun=None, basesAvNPort=None, infoSubstPatrOpPort=None):
        self.original_tagname_ = None
        self.codLotacao = codLotacao
        self.fpas = fpas
        self.codTercs = codTercs
        self.codTercsSusp = codTercsSusp
        if infoTercSusp is None:
            self.infoTercSusp = []
        else:
            self.infoTercSusp = infoTercSusp
        self.infoEmprParcial = infoEmprParcial
        self.dadosOpPort = dadosOpPort
        if basesRemun is None:
            self.basesRemun = []
        else:
            self.basesRemun = basesRemun
        self.basesAvNPort = basesAvNPort
        if infoSubstPatrOpPort is None:
            self.infoSubstPatrOpPort = []
        else:
            self.infoSubstPatrOpPort = infoSubstPatrOpPort
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideLotacao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideLotacao.subclass:
            return ideLotacao.subclass(*args_, **kwargs_)
        else:
            return ideLotacao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codLotacao(self): return self.codLotacao
    def set_codLotacao(self, codLotacao): self.codLotacao = codLotacao
    def get_fpas(self): return self.fpas
    def set_fpas(self, fpas): self.fpas = fpas
    def get_codTercs(self): return self.codTercs
    def set_codTercs(self, codTercs): self.codTercs = codTercs
    def get_codTercsSusp(self): return self.codTercsSusp
    def set_codTercsSusp(self, codTercsSusp): self.codTercsSusp = codTercsSusp
    def get_infoTercSusp(self): return self.infoTercSusp
    def set_infoTercSusp(self, infoTercSusp): self.infoTercSusp = infoTercSusp
    def add_infoTercSusp(self, value): self.infoTercSusp.append(value)
    def insert_infoTercSusp_at(self, index, value): self.infoTercSusp.insert(index, value)
    def replace_infoTercSusp_at(self, index, value): self.infoTercSusp[index] = value
    def get_infoEmprParcial(self): return self.infoEmprParcial
    def set_infoEmprParcial(self, infoEmprParcial): self.infoEmprParcial = infoEmprParcial
    def get_dadosOpPort(self): return self.dadosOpPort
    def set_dadosOpPort(self, dadosOpPort): self.dadosOpPort = dadosOpPort
    def get_basesRemun(self): return self.basesRemun
    def set_basesRemun(self, basesRemun): self.basesRemun = basesRemun
    def add_basesRemun(self, value): self.basesRemun.append(value)
    def insert_basesRemun_at(self, index, value): self.basesRemun.insert(index, value)
    def replace_basesRemun_at(self, index, value): self.basesRemun[index] = value
    def get_basesAvNPort(self): return self.basesAvNPort
    def set_basesAvNPort(self, basesAvNPort): self.basesAvNPort = basesAvNPort
    def get_infoSubstPatrOpPort(self): return self.infoSubstPatrOpPort
    def set_infoSubstPatrOpPort(self, infoSubstPatrOpPort): self.infoSubstPatrOpPort = infoSubstPatrOpPort
    def add_infoSubstPatrOpPort(self, value): self.infoSubstPatrOpPort.append(value)
    def insert_infoSubstPatrOpPort_at(self, index, value): self.infoSubstPatrOpPort.insert(index, value)
    def replace_infoSubstPatrOpPort_at(self, index, value): self.infoSubstPatrOpPort[index] = value
    def hasContent_(self):
        if (
            self.codLotacao is not None or
            self.fpas is not None or
            self.codTercs is not None or
            self.codTercsSusp is not None or
            self.infoTercSusp or
            self.infoEmprParcial is not None or
            self.dadosOpPort is not None or
            self.basesRemun or
            self.basesAvNPort is not None or
            self.infoSubstPatrOpPort
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideLotacao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideLotacao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideLotacao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideLotacao', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideLotacao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideLotacao', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codLotacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodLotacao>%s</%scodLotacao>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codLotacao), input_name='codLotacao')), namespace_, eol_))
        if self.fpas is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfpas>%s</%sfpas>%s' % (namespace_, self.gds_format_integer(self.fpas, input_name='fpas'), namespace_, eol_))
        if self.codTercs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodTercs>%s</%scodTercs>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codTercs), input_name='codTercs')), namespace_, eol_))
        if self.codTercsSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodTercsSusp>%s</%scodTercsSusp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codTercsSusp), input_name='codTercsSusp')), namespace_, eol_))
        for infoTercSusp_ in self.infoTercSusp:
            infoTercSusp_.export(outfile, level, namespace_, name_='infoTercSusp', pretty_print=pretty_print)
        if self.infoEmprParcial is not None:
            self.infoEmprParcial.export(outfile, level, namespace_, name_='infoEmprParcial', pretty_print=pretty_print)
        if self.dadosOpPort is not None:
            self.dadosOpPort.export(outfile, level, namespace_, name_='dadosOpPort', pretty_print=pretty_print)
        for basesRemun_ in self.basesRemun:
            basesRemun_.export(outfile, level, namespace_, name_='basesRemun', pretty_print=pretty_print)
        if self.basesAvNPort is not None:
            self.basesAvNPort.export(outfile, level, namespace_, name_='basesAvNPort', pretty_print=pretty_print)
        for infoSubstPatrOpPort_ in self.infoSubstPatrOpPort:
            infoSubstPatrOpPort_.export(outfile, level, namespace_, name_='infoSubstPatrOpPort', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codLotacao':
            codLotacao_ = child_.text
            codLotacao_ = self.gds_validate_string(codLotacao_, node, 'codLotacao')
            self.codLotacao = codLotacao_
        elif nodeName_ == 'fpas':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fpas')
            self.fpas = ival_
        elif nodeName_ == 'codTercs':
            codTercs_ = child_.text
            codTercs_ = self.gds_validate_string(codTercs_, node, 'codTercs')
            self.codTercs = codTercs_
        elif nodeName_ == 'codTercsSusp':
            codTercsSusp_ = child_.text
            codTercsSusp_ = self.gds_validate_string(codTercsSusp_, node, 'codTercsSusp')
            self.codTercsSusp = codTercsSusp_
        elif nodeName_ == 'infoTercSusp':
            obj_ = infoTercSusp.factory()
            obj_.build(child_)
            self.infoTercSusp.append(obj_)
            obj_.original_tagname_ = 'infoTercSusp'
        elif nodeName_ == 'infoEmprParcial':
            obj_ = infoEmprParcial.factory()
            obj_.build(child_)
            self.infoEmprParcial = obj_
            obj_.original_tagname_ = 'infoEmprParcial'
        elif nodeName_ == 'dadosOpPort':
            obj_ = dadosOpPort.factory()
            obj_.build(child_)
            self.dadosOpPort = obj_
            obj_.original_tagname_ = 'dadosOpPort'
        elif nodeName_ == 'basesRemun':
            obj_ = basesRemun.factory()
            obj_.build(child_)
            self.basesRemun.append(obj_)
            obj_.original_tagname_ = 'basesRemun'
        elif nodeName_ == 'basesAvNPort':
            obj_ = basesAvNPort.factory()
            obj_.build(child_)
            self.basesAvNPort = obj_
            obj_.original_tagname_ = 'basesAvNPort'
        elif nodeName_ == 'infoSubstPatrOpPort':
            obj_ = infoSubstPatrOpPort.factory()
            obj_.build(child_)
            self.infoSubstPatrOpPort.append(obj_)
            obj_.original_tagname_ = 'infoSubstPatrOpPort'
# end class ideLotacao


class codLotacao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codLotacao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codLotacao.subclass:
            return codLotacao.subclass(*args_, **kwargs_)
        else:
            return codLotacao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codLotacao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codLotacao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codLotacao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codLotacao', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codLotacao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codLotacao', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codLotacao


class fpas(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fpas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fpas.subclass:
            return fpas.subclass(*args_, **kwargs_)
        else:
            return fpas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fpas', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fpas')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fpas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fpas', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fpas'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fpas', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fpas


class codTercs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codTercs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codTercs.subclass:
            return codTercs.subclass(*args_, **kwargs_)
        else:
            return codTercs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codTercs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codTercs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codTercs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codTercs', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codTercs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codTercs', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codTercs


class codTercsSusp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codTercsSusp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codTercsSusp.subclass:
            return codTercsSusp.subclass(*args_, **kwargs_)
        else:
            return codTercsSusp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codTercsSusp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codTercsSusp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codTercsSusp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codTercsSusp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codTercsSusp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codTercsSusp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codTercsSusp


class infoTercSusp(GeneratedsSuper):
    """Informações de suspensão de contribuições destinadas a Outras
    Entidades e Fundos (Terceiros)."""
    subclass = None
    superclass = None
    def __init__(self, codTerc=None):
        self.original_tagname_ = None
        self.codTerc = codTerc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoTercSusp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoTercSusp.subclass:
            return infoTercSusp.subclass(*args_, **kwargs_)
        else:
            return infoTercSusp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codTerc(self): return self.codTerc
    def set_codTerc(self, codTerc): self.codTerc = codTerc
    def hasContent_(self):
        if (
            self.codTerc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoTercSusp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoTercSusp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoTercSusp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoTercSusp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoTercSusp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoTercSusp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codTerc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodTerc>%s</%scodTerc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codTerc), input_name='codTerc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codTerc':
            codTerc_ = child_.text
            codTerc_ = self.gds_validate_string(codTerc_, node, 'codTerc')
            self.codTerc = codTerc_
# end class infoTercSusp


class codTerc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codTerc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codTerc.subclass:
            return codTerc.subclass(*args_, **kwargs_)
        else:
            return codTerc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codTerc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codTerc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codTerc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codTerc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codTerc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codTerc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codTerc


class infoEmprParcial(GeneratedsSuper):
    """Informação complementar destinada à identificação do contratante e
    do proprietário de obra de construção civil contratada sob
    regime de empreitada parcial ou subempreitada. A informação é
    preenchida exclusivamente para lotações cujo {tpLotacao} seja
    igual a [2]."""
    subclass = None
    superclass = None
    def __init__(self, tpInscContrat=None, nrInscContrat=None, tpInscProp=None, nrInscProp=None):
        self.original_tagname_ = None
        self.tpInscContrat = tpInscContrat
        self.nrInscContrat = nrInscContrat
        self.tpInscProp = tpInscProp
        self.nrInscProp = nrInscProp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoEmprParcial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoEmprParcial.subclass:
            return infoEmprParcial.subclass(*args_, **kwargs_)
        else:
            return infoEmprParcial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInscContrat(self): return self.tpInscContrat
    def set_tpInscContrat(self, tpInscContrat): self.tpInscContrat = tpInscContrat
    def get_nrInscContrat(self): return self.nrInscContrat
    def set_nrInscContrat(self, nrInscContrat): self.nrInscContrat = nrInscContrat
    def get_tpInscProp(self): return self.tpInscProp
    def set_tpInscProp(self, tpInscProp): self.tpInscProp = tpInscProp
    def get_nrInscProp(self): return self.nrInscProp
    def set_nrInscProp(self, nrInscProp): self.nrInscProp = nrInscProp
    def hasContent_(self):
        if (
            self.tpInscContrat is not None or
            self.nrInscContrat is not None or
            self.tpInscProp is not None or
            self.nrInscProp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoEmprParcial', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoEmprParcial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoEmprParcial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoEmprParcial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoEmprParcial'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoEmprParcial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInscContrat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInscContrat>%s</%stpInscContrat>%s' % (namespace_, self.gds_format_integer(self.tpInscContrat, input_name='tpInscContrat'), namespace_, eol_))
        if self.nrInscContrat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInscContrat>%s</%snrInscContrat>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInscContrat), input_name='nrInscContrat')), namespace_, eol_))
        if self.tpInscProp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInscProp>%s</%stpInscProp>%s' % (namespace_, self.gds_format_integer(self.tpInscProp, input_name='tpInscProp'), namespace_, eol_))
        if self.nrInscProp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInscProp>%s</%snrInscProp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInscProp), input_name='nrInscProp')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInscContrat':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInscContrat')
            self.tpInscContrat = ival_
        elif nodeName_ == 'nrInscContrat':
            nrInscContrat_ = child_.text
            nrInscContrat_ = self.gds_validate_string(nrInscContrat_, node, 'nrInscContrat')
            self.nrInscContrat = nrInscContrat_
        elif nodeName_ == 'tpInscProp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInscProp')
            self.tpInscProp = ival_
        elif nodeName_ == 'nrInscProp':
            nrInscProp_ = child_.text
            nrInscProp_ = self.gds_validate_string(nrInscProp_, node, 'nrInscProp')
            self.nrInscProp = nrInscProp_
# end class infoEmprParcial


class tpInscContrat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpInscContrat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpInscContrat.subclass:
            return tpInscContrat.subclass(*args_, **kwargs_)
        else:
            return tpInscContrat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpInscContrat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpInscContrat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpInscContrat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpInscContrat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpInscContrat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpInscContrat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpInscContrat


class nrInscContrat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrInscContrat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrInscContrat.subclass:
            return nrInscContrat.subclass(*args_, **kwargs_)
        else:
            return nrInscContrat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrInscContrat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrInscContrat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrInscContrat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrInscContrat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrInscContrat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrInscContrat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrInscContrat


class tpInscProp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpInscProp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpInscProp.subclass:
            return tpInscProp.subclass(*args_, **kwargs_)
        else:
            return tpInscProp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpInscProp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpInscProp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpInscProp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpInscProp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpInscProp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpInscProp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpInscProp


class nrInscProp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrInscProp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrInscProp.subclass:
            return nrInscProp.subclass(*args_, **kwargs_)
        else:
            return nrInscProp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrInscProp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrInscProp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrInscProp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrInscProp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrInscProp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrInscProp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrInscProp


class dadosOpPort(GeneratedsSuper):
    """Detalhamento das informações do Operador Portuário que está sendo
    incluído (origem S-1080)."""
    subclass = None
    superclass = None
    def __init__(self, cnpjOpPortuario=None, aliqRat=None, fap=None, aliqRatAjust=None):
        self.original_tagname_ = None
        self.cnpjOpPortuario = cnpjOpPortuario
        self.aliqRat = aliqRat
        self.fap = fap
        self.aliqRatAjust = aliqRatAjust
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dadosOpPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dadosOpPort.subclass:
            return dadosOpPort.subclass(*args_, **kwargs_)
        else:
            return dadosOpPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnpjOpPortuario(self): return self.cnpjOpPortuario
    def set_cnpjOpPortuario(self, cnpjOpPortuario): self.cnpjOpPortuario = cnpjOpPortuario
    def get_aliqRat(self): return self.aliqRat
    def set_aliqRat(self, aliqRat): self.aliqRat = aliqRat
    def get_fap(self): return self.fap
    def set_fap(self, fap): self.fap = fap
    def get_aliqRatAjust(self): return self.aliqRatAjust
    def set_aliqRatAjust(self, aliqRatAjust): self.aliqRatAjust = aliqRatAjust
    def hasContent_(self):
        if (
            self.cnpjOpPortuario is not None or
            self.aliqRat is not None or
            self.fap is not None or
            self.aliqRatAjust is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dadosOpPort', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dadosOpPort')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dadosOpPort')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dadosOpPort', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dadosOpPort'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dadosOpPort', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnpjOpPortuario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scnpjOpPortuario>%s</%scnpjOpPortuario>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cnpjOpPortuario), input_name='cnpjOpPortuario')), namespace_, eol_))
        if self.aliqRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saliqRat>%s</%saliqRat>%s' % (namespace_, self.gds_format_integer(self.aliqRat, input_name='aliqRat'), namespace_, eol_))
        if self.fap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfap>%s</%sfap>%s' % (namespace_, self.gds_format_float(self.fap, input_name='fap'), namespace_, eol_))
        if self.aliqRatAjust is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saliqRatAjust>%s</%saliqRatAjust>%s' % (namespace_, self.gds_format_float(self.aliqRatAjust, input_name='aliqRatAjust'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnpjOpPortuario':
            cnpjOpPortuario_ = child_.text
            cnpjOpPortuario_ = self.gds_validate_string(cnpjOpPortuario_, node, 'cnpjOpPortuario')
            self.cnpjOpPortuario = cnpjOpPortuario_
        elif nodeName_ == 'aliqRat':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'aliqRat')
            self.aliqRat = ival_
        elif nodeName_ == 'fap':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fap')
            self.fap = fval_
        elif nodeName_ == 'aliqRatAjust':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'aliqRatAjust')
            self.aliqRatAjust = fval_
# end class dadosOpPort


class cnpjOpPortuario(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cnpjOpPortuario)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cnpjOpPortuario.subclass:
            return cnpjOpPortuario.subclass(*args_, **kwargs_)
        else:
            return cnpjOpPortuario(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cnpjOpPortuario', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cnpjOpPortuario')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cnpjOpPortuario')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cnpjOpPortuario', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cnpjOpPortuario'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cnpjOpPortuario', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cnpjOpPortuario


class basesRemun(GeneratedsSuper):
    """Bases de cálculo da contribuição previdenciária incidente sobre
    remunerações, por categoria."""
    subclass = None
    superclass = None
    def __init__(self, indIncid=None, codCateg=None, basesCp=None):
        self.original_tagname_ = None
        self.indIncid = indIncid
        self.codCateg = codCateg
        self.basesCp = basesCp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesRemun)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesRemun.subclass:
            return basesRemun.subclass(*args_, **kwargs_)
        else:
            return basesRemun(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indIncid(self): return self.indIncid
    def set_indIncid(self, indIncid): self.indIncid = indIncid
    def get_codCateg(self): return self.codCateg
    def set_codCateg(self, codCateg): self.codCateg = codCateg
    def get_basesCp(self): return self.basesCp
    def set_basesCp(self, basesCp): self.basesCp = basesCp
    def hasContent_(self):
        if (
            self.indIncid is not None or
            self.codCateg is not None or
            self.basesCp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='basesRemun', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesRemun')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='basesRemun')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='basesRemun', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='basesRemun'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='basesRemun', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indIncid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindIncid>%s</%sindIncid>%s' % (namespace_, self.gds_format_integer(self.indIncid, input_name='indIncid'), namespace_, eol_))
        if self.codCateg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodCateg>%s</%scodCateg>%s' % (namespace_, self.gds_format_integer(self.codCateg, input_name='codCateg'), namespace_, eol_))
        if self.basesCp is not None:
            self.basesCp.export(outfile, level, namespace_, name_='basesCp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indIncid':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indIncid')
            self.indIncid = ival_
        elif nodeName_ == 'codCateg':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codCateg')
            self.codCateg = ival_
        elif nodeName_ == 'basesCp':
            obj_ = basesCp.factory()
            obj_.build(child_)
            self.basesCp = obj_
            obj_.original_tagname_ = 'basesCp'
# end class basesRemun


class indIncid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indIncid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indIncid.subclass:
            return indIncid.subclass(*args_, **kwargs_)
        else:
            return indIncid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indIncid', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indIncid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indIncid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indIncid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indIncid'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indIncid', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indIncid


class codCateg(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codCateg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codCateg.subclass:
            return codCateg.subclass(*args_, **kwargs_)
        else:
            return codCateg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codCateg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codCateg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codCateg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codCateg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codCateg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codCateg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codCateg


class basesCp(GeneratedsSuper):
    """Valores correspondentes às bases, contribuições do segurado e
    deduções da contribuição previdenciária."""
    subclass = None
    superclass = None
    def __init__(self, vrBcCp00=None, vrBcCp15=None, vrBcCp20=None, vrBcCp25=None, vrSuspBcCp00=None, vrSuspBcCp15=None, vrSuspBcCp20=None, vrSuspBcCp25=None, vrDescSest=None, vrCalcSest=None, vrDescSenat=None, vrCalcSenat=None, vrSalFam=None, vrSalMat=None):
        self.original_tagname_ = None
        self.vrBcCp00 = vrBcCp00
        self.vrBcCp15 = vrBcCp15
        self.vrBcCp20 = vrBcCp20
        self.vrBcCp25 = vrBcCp25
        self.vrSuspBcCp00 = vrSuspBcCp00
        self.vrSuspBcCp15 = vrSuspBcCp15
        self.vrSuspBcCp20 = vrSuspBcCp20
        self.vrSuspBcCp25 = vrSuspBcCp25
        self.vrDescSest = vrDescSest
        self.vrCalcSest = vrCalcSest
        self.vrDescSenat = vrDescSenat
        self.vrCalcSenat = vrCalcSenat
        self.vrSalFam = vrSalFam
        self.vrSalMat = vrSalMat
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesCp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesCp.subclass:
            return basesCp.subclass(*args_, **kwargs_)
        else:
            return basesCp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vrBcCp00(self): return self.vrBcCp00
    def set_vrBcCp00(self, vrBcCp00): self.vrBcCp00 = vrBcCp00
    def get_vrBcCp15(self): return self.vrBcCp15
    def set_vrBcCp15(self, vrBcCp15): self.vrBcCp15 = vrBcCp15
    def get_vrBcCp20(self): return self.vrBcCp20
    def set_vrBcCp20(self, vrBcCp20): self.vrBcCp20 = vrBcCp20
    def get_vrBcCp25(self): return self.vrBcCp25
    def set_vrBcCp25(self, vrBcCp25): self.vrBcCp25 = vrBcCp25
    def get_vrSuspBcCp00(self): return self.vrSuspBcCp00
    def set_vrSuspBcCp00(self, vrSuspBcCp00): self.vrSuspBcCp00 = vrSuspBcCp00
    def get_vrSuspBcCp15(self): return self.vrSuspBcCp15
    def set_vrSuspBcCp15(self, vrSuspBcCp15): self.vrSuspBcCp15 = vrSuspBcCp15
    def get_vrSuspBcCp20(self): return self.vrSuspBcCp20
    def set_vrSuspBcCp20(self, vrSuspBcCp20): self.vrSuspBcCp20 = vrSuspBcCp20
    def get_vrSuspBcCp25(self): return self.vrSuspBcCp25
    def set_vrSuspBcCp25(self, vrSuspBcCp25): self.vrSuspBcCp25 = vrSuspBcCp25
    def get_vrDescSest(self): return self.vrDescSest
    def set_vrDescSest(self, vrDescSest): self.vrDescSest = vrDescSest
    def get_vrCalcSest(self): return self.vrCalcSest
    def set_vrCalcSest(self, vrCalcSest): self.vrCalcSest = vrCalcSest
    def get_vrDescSenat(self): return self.vrDescSenat
    def set_vrDescSenat(self, vrDescSenat): self.vrDescSenat = vrDescSenat
    def get_vrCalcSenat(self): return self.vrCalcSenat
    def set_vrCalcSenat(self, vrCalcSenat): self.vrCalcSenat = vrCalcSenat
    def get_vrSalFam(self): return self.vrSalFam
    def set_vrSalFam(self, vrSalFam): self.vrSalFam = vrSalFam
    def get_vrSalMat(self): return self.vrSalMat
    def set_vrSalMat(self, vrSalMat): self.vrSalMat = vrSalMat
    def hasContent_(self):
        if (
            self.vrBcCp00 is not None or
            self.vrBcCp15 is not None or
            self.vrBcCp20 is not None or
            self.vrBcCp25 is not None or
            self.vrSuspBcCp00 is not None or
            self.vrSuspBcCp15 is not None or
            self.vrSuspBcCp20 is not None or
            self.vrSuspBcCp25 is not None or
            self.vrDescSest is not None or
            self.vrCalcSest is not None or
            self.vrDescSenat is not None or
            self.vrCalcSenat is not None or
            self.vrSalFam is not None or
            self.vrSalMat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='basesCp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesCp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='basesCp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='basesCp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='basesCp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='basesCp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vrBcCp00 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcCp00>%s</%svrBcCp00>%s' % (namespace_, self.gds_format_float(self.vrBcCp00, input_name='vrBcCp00'), namespace_, eol_))
        if self.vrBcCp15 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcCp15>%s</%svrBcCp15>%s' % (namespace_, self.gds_format_float(self.vrBcCp15, input_name='vrBcCp15'), namespace_, eol_))
        if self.vrBcCp20 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcCp20>%s</%svrBcCp20>%s' % (namespace_, self.gds_format_float(self.vrBcCp20, input_name='vrBcCp20'), namespace_, eol_))
        if self.vrBcCp25 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcCp25>%s</%svrBcCp25>%s' % (namespace_, self.gds_format_float(self.vrBcCp25, input_name='vrBcCp25'), namespace_, eol_))
        if self.vrSuspBcCp00 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSuspBcCp00>%s</%svrSuspBcCp00>%s' % (namespace_, self.gds_format_float(self.vrSuspBcCp00, input_name='vrSuspBcCp00'), namespace_, eol_))
        if self.vrSuspBcCp15 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSuspBcCp15>%s</%svrSuspBcCp15>%s' % (namespace_, self.gds_format_float(self.vrSuspBcCp15, input_name='vrSuspBcCp15'), namespace_, eol_))
        if self.vrSuspBcCp20 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSuspBcCp20>%s</%svrSuspBcCp20>%s' % (namespace_, self.gds_format_float(self.vrSuspBcCp20, input_name='vrSuspBcCp20'), namespace_, eol_))
        if self.vrSuspBcCp25 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSuspBcCp25>%s</%svrSuspBcCp25>%s' % (namespace_, self.gds_format_float(self.vrSuspBcCp25, input_name='vrSuspBcCp25'), namespace_, eol_))
        if self.vrDescSest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrDescSest>%s</%svrDescSest>%s' % (namespace_, self.gds_format_float(self.vrDescSest, input_name='vrDescSest'), namespace_, eol_))
        if self.vrCalcSest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCalcSest>%s</%svrCalcSest>%s' % (namespace_, self.gds_format_float(self.vrCalcSest, input_name='vrCalcSest'), namespace_, eol_))
        if self.vrDescSenat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrDescSenat>%s</%svrDescSenat>%s' % (namespace_, self.gds_format_float(self.vrDescSenat, input_name='vrDescSenat'), namespace_, eol_))
        if self.vrCalcSenat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCalcSenat>%s</%svrCalcSenat>%s' % (namespace_, self.gds_format_float(self.vrCalcSenat, input_name='vrCalcSenat'), namespace_, eol_))
        if self.vrSalFam is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSalFam>%s</%svrSalFam>%s' % (namespace_, self.gds_format_float(self.vrSalFam, input_name='vrSalFam'), namespace_, eol_))
        if self.vrSalMat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSalMat>%s</%svrSalMat>%s' % (namespace_, self.gds_format_float(self.vrSalMat, input_name='vrSalMat'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vrBcCp00':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp00')
            self.vrBcCp00 = fval_
        elif nodeName_ == 'vrBcCp15':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp15')
            self.vrBcCp15 = fval_
        elif nodeName_ == 'vrBcCp20':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp20')
            self.vrBcCp20 = fval_
        elif nodeName_ == 'vrBcCp25':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp25')
            self.vrBcCp25 = fval_
        elif nodeName_ == 'vrSuspBcCp00':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspBcCp00')
            self.vrSuspBcCp00 = fval_
        elif nodeName_ == 'vrSuspBcCp15':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspBcCp15')
            self.vrSuspBcCp15 = fval_
        elif nodeName_ == 'vrSuspBcCp20':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspBcCp20')
            self.vrSuspBcCp20 = fval_
        elif nodeName_ == 'vrSuspBcCp25':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspBcCp25')
            self.vrSuspBcCp25 = fval_
        elif nodeName_ == 'vrDescSest':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrDescSest')
            self.vrDescSest = fval_
        elif nodeName_ == 'vrCalcSest':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCalcSest')
            self.vrCalcSest = fval_
        elif nodeName_ == 'vrDescSenat':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrDescSenat')
            self.vrDescSenat = fval_
        elif nodeName_ == 'vrCalcSenat':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCalcSenat')
            self.vrCalcSenat = fval_
        elif nodeName_ == 'vrSalFam':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSalFam')
            self.vrSalFam = fval_
        elif nodeName_ == 'vrSalMat':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSalMat')
            self.vrSalMat = fval_
# end class basesCp


class vrBcCp00(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrBcCp00)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrBcCp00.subclass:
            return vrBcCp00.subclass(*args_, **kwargs_)
        else:
            return vrBcCp00(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrBcCp00', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrBcCp00')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrBcCp00')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrBcCp00', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrBcCp00'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrBcCp00', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrBcCp00


class vrBcCp15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrBcCp15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrBcCp15.subclass:
            return vrBcCp15.subclass(*args_, **kwargs_)
        else:
            return vrBcCp15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrBcCp15', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrBcCp15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrBcCp15')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrBcCp15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrBcCp15'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrBcCp15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrBcCp15


class vrBcCp20(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrBcCp20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrBcCp20.subclass:
            return vrBcCp20.subclass(*args_, **kwargs_)
        else:
            return vrBcCp20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrBcCp20', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrBcCp20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrBcCp20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrBcCp20', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrBcCp20'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrBcCp20', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrBcCp20


class vrBcCp25(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrBcCp25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrBcCp25.subclass:
            return vrBcCp25.subclass(*args_, **kwargs_)
        else:
            return vrBcCp25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrBcCp25', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrBcCp25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrBcCp25')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrBcCp25', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrBcCp25'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrBcCp25', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrBcCp25


class vrSuspBcCp00(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSuspBcCp00)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSuspBcCp00.subclass:
            return vrSuspBcCp00.subclass(*args_, **kwargs_)
        else:
            return vrSuspBcCp00(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSuspBcCp00', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSuspBcCp00')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSuspBcCp00')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSuspBcCp00', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSuspBcCp00'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSuspBcCp00', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSuspBcCp00


class vrSuspBcCp15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSuspBcCp15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSuspBcCp15.subclass:
            return vrSuspBcCp15.subclass(*args_, **kwargs_)
        else:
            return vrSuspBcCp15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSuspBcCp15', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSuspBcCp15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSuspBcCp15')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSuspBcCp15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSuspBcCp15'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSuspBcCp15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSuspBcCp15


class vrSuspBcCp20(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSuspBcCp20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSuspBcCp20.subclass:
            return vrSuspBcCp20.subclass(*args_, **kwargs_)
        else:
            return vrSuspBcCp20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSuspBcCp20', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSuspBcCp20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSuspBcCp20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSuspBcCp20', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSuspBcCp20'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSuspBcCp20', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSuspBcCp20


class vrSuspBcCp25(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSuspBcCp25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSuspBcCp25.subclass:
            return vrSuspBcCp25.subclass(*args_, **kwargs_)
        else:
            return vrSuspBcCp25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSuspBcCp25', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSuspBcCp25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSuspBcCp25')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSuspBcCp25', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSuspBcCp25'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSuspBcCp25', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSuspBcCp25


class vrDescSest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrDescSest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrDescSest.subclass:
            return vrDescSest.subclass(*args_, **kwargs_)
        else:
            return vrDescSest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrDescSest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrDescSest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrDescSest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrDescSest', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrDescSest'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrDescSest', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrDescSest


class vrCalcSest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrCalcSest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrCalcSest.subclass:
            return vrCalcSest.subclass(*args_, **kwargs_)
        else:
            return vrCalcSest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrCalcSest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrCalcSest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrCalcSest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrCalcSest', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrCalcSest'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrCalcSest', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrCalcSest


class vrDescSenat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrDescSenat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrDescSenat.subclass:
            return vrDescSenat.subclass(*args_, **kwargs_)
        else:
            return vrDescSenat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrDescSenat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrDescSenat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrDescSenat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrDescSenat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrDescSenat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrDescSenat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrDescSenat


class vrCalcSenat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrCalcSenat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrCalcSenat.subclass:
            return vrCalcSenat.subclass(*args_, **kwargs_)
        else:
            return vrCalcSenat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrCalcSenat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrCalcSenat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrCalcSenat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrCalcSenat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrCalcSenat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrCalcSenat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrCalcSenat


class vrSalFam(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSalFam)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSalFam.subclass:
            return vrSalFam.subclass(*args_, **kwargs_)
        else:
            return vrSalFam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSalFam', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSalFam')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSalFam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSalFam', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSalFam'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSalFam', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSalFam


class vrSalMat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSalMat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSalMat.subclass:
            return vrSalMat.subclass(*args_, **kwargs_)
        else:
            return vrSalMat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSalMat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSalMat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSalMat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSalMat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSalMat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSalMat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSalMat


class basesAvNPort(GeneratedsSuper):
    """Informações de bases de cálculo relativas à contratação de
    trabalhadores avulsos não portuários. Informações desse grupo
    conforme informado pelo contribuinte em S-1270."""
    subclass = None
    superclass = None
    def __init__(self, vrBcCp00=None, vrBcCp15=None, vrBcCp20=None, vrBcCp25=None, vrBcCp13=None, vrBcFgts=None, vrDescCP=None):
        self.original_tagname_ = None
        self.vrBcCp00 = vrBcCp00
        self.vrBcCp15 = vrBcCp15
        self.vrBcCp20 = vrBcCp20
        self.vrBcCp25 = vrBcCp25
        self.vrBcCp13 = vrBcCp13
        self.vrBcFgts = vrBcFgts
        self.vrDescCP = vrDescCP
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesAvNPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesAvNPort.subclass:
            return basesAvNPort.subclass(*args_, **kwargs_)
        else:
            return basesAvNPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vrBcCp00(self): return self.vrBcCp00
    def set_vrBcCp00(self, vrBcCp00): self.vrBcCp00 = vrBcCp00
    def get_vrBcCp15(self): return self.vrBcCp15
    def set_vrBcCp15(self, vrBcCp15): self.vrBcCp15 = vrBcCp15
    def get_vrBcCp20(self): return self.vrBcCp20
    def set_vrBcCp20(self, vrBcCp20): self.vrBcCp20 = vrBcCp20
    def get_vrBcCp25(self): return self.vrBcCp25
    def set_vrBcCp25(self, vrBcCp25): self.vrBcCp25 = vrBcCp25
    def get_vrBcCp13(self): return self.vrBcCp13
    def set_vrBcCp13(self, vrBcCp13): self.vrBcCp13 = vrBcCp13
    def get_vrBcFgts(self): return self.vrBcFgts
    def set_vrBcFgts(self, vrBcFgts): self.vrBcFgts = vrBcFgts
    def get_vrDescCP(self): return self.vrDescCP
    def set_vrDescCP(self, vrDescCP): self.vrDescCP = vrDescCP
    def hasContent_(self):
        if (
            self.vrBcCp00 is not None or
            self.vrBcCp15 is not None or
            self.vrBcCp20 is not None or
            self.vrBcCp25 is not None or
            self.vrBcCp13 is not None or
            self.vrBcFgts is not None or
            self.vrDescCP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='basesAvNPort', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesAvNPort')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='basesAvNPort')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='basesAvNPort', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='basesAvNPort'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='basesAvNPort', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vrBcCp00 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcCp00>%s</%svrBcCp00>%s' % (namespace_, self.gds_format_float(self.vrBcCp00, input_name='vrBcCp00'), namespace_, eol_))
        if self.vrBcCp15 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcCp15>%s</%svrBcCp15>%s' % (namespace_, self.gds_format_float(self.vrBcCp15, input_name='vrBcCp15'), namespace_, eol_))
        if self.vrBcCp20 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcCp20>%s</%svrBcCp20>%s' % (namespace_, self.gds_format_float(self.vrBcCp20, input_name='vrBcCp20'), namespace_, eol_))
        if self.vrBcCp25 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcCp25>%s</%svrBcCp25>%s' % (namespace_, self.gds_format_float(self.vrBcCp25, input_name='vrBcCp25'), namespace_, eol_))
        if self.vrBcCp13 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcCp13>%s</%svrBcCp13>%s' % (namespace_, self.gds_format_float(self.vrBcCp13, input_name='vrBcCp13'), namespace_, eol_))
        if self.vrBcFgts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcFgts>%s</%svrBcFgts>%s' % (namespace_, self.gds_format_float(self.vrBcFgts, input_name='vrBcFgts'), namespace_, eol_))
        if self.vrDescCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrDescCP>%s</%svrDescCP>%s' % (namespace_, self.gds_format_float(self.vrDescCP, input_name='vrDescCP'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vrBcCp00':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp00')
            self.vrBcCp00 = fval_
        elif nodeName_ == 'vrBcCp15':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp15')
            self.vrBcCp15 = fval_
        elif nodeName_ == 'vrBcCp20':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp20')
            self.vrBcCp20 = fval_
        elif nodeName_ == 'vrBcCp25':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp25')
            self.vrBcCp25 = fval_
        elif nodeName_ == 'vrBcCp13':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp13')
            self.vrBcCp13 = fval_
        elif nodeName_ == 'vrBcFgts':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcFgts')
            self.vrBcFgts = fval_
        elif nodeName_ == 'vrDescCP':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrDescCP')
            self.vrDescCP = fval_
# end class basesAvNPort


class vrBcCp13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrBcCp13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrBcCp13.subclass:
            return vrBcCp13.subclass(*args_, **kwargs_)
        else:
            return vrBcCp13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrBcCp13', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrBcCp13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrBcCp13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrBcCp13', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrBcCp13'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrBcCp13', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrBcCp13


class vrBcFgts(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrBcFgts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrBcFgts.subclass:
            return vrBcFgts.subclass(*args_, **kwargs_)
        else:
            return vrBcFgts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrBcFgts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrBcFgts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrBcFgts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrBcFgts', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrBcFgts'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrBcFgts', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrBcFgts


class infoSubstPatrOpPort(GeneratedsSuper):
    """Registro preenchido exclusivamente pelo OGMO ({classTrib}=[09])
    relativamente a seus Operadores Portuários enquadrados nos
    artigos 7 a 9 da Lei 12.546/2011."""
    subclass = None
    superclass = None
    def __init__(self, cnpjOpPortuario=None):
        self.original_tagname_ = None
        self.cnpjOpPortuario = cnpjOpPortuario
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoSubstPatrOpPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoSubstPatrOpPort.subclass:
            return infoSubstPatrOpPort.subclass(*args_, **kwargs_)
        else:
            return infoSubstPatrOpPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnpjOpPortuario(self): return self.cnpjOpPortuario
    def set_cnpjOpPortuario(self, cnpjOpPortuario): self.cnpjOpPortuario = cnpjOpPortuario
    def hasContent_(self):
        if (
            self.cnpjOpPortuario is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoSubstPatrOpPort', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoSubstPatrOpPort')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoSubstPatrOpPort')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoSubstPatrOpPort', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoSubstPatrOpPort'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoSubstPatrOpPort', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnpjOpPortuario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scnpjOpPortuario>%s</%scnpjOpPortuario>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cnpjOpPortuario), input_name='cnpjOpPortuario')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnpjOpPortuario':
            cnpjOpPortuario_ = child_.text
            cnpjOpPortuario_ = self.gds_validate_string(cnpjOpPortuario_, node, 'cnpjOpPortuario')
            self.cnpjOpPortuario = cnpjOpPortuario_
# end class infoSubstPatrOpPort


class basesAquis(GeneratedsSuper):
    """Informações de bases de cálculo relativas a aquisição de produção
    rural. Origem S-1250."""
    subclass = None
    superclass = None
    def __init__(self, indAquis=None, vlrAquis=None, vrCPDescPR=None, vrCPNRet=None, vrRatNRet=None, vrSenarNRet=None, vrCPCalcPR=None, vrRatDescPR=None, vrRatCalcPR=None, vrSenarDesc=None, vrSenarCalc=None):
        self.original_tagname_ = None
        self.indAquis = indAquis
        self.vlrAquis = vlrAquis
        self.vrCPDescPR = vrCPDescPR
        self.vrCPNRet = vrCPNRet
        self.vrRatNRet = vrRatNRet
        self.vrSenarNRet = vrSenarNRet
        self.vrCPCalcPR = vrCPCalcPR
        self.vrRatDescPR = vrRatDescPR
        self.vrRatCalcPR = vrRatCalcPR
        self.vrSenarDesc = vrSenarDesc
        self.vrSenarCalc = vrSenarCalc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesAquis)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesAquis.subclass:
            return basesAquis.subclass(*args_, **kwargs_)
        else:
            return basesAquis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indAquis(self): return self.indAquis
    def set_indAquis(self, indAquis): self.indAquis = indAquis
    def get_vlrAquis(self): return self.vlrAquis
    def set_vlrAquis(self, vlrAquis): self.vlrAquis = vlrAquis
    def get_vrCPDescPR(self): return self.vrCPDescPR
    def set_vrCPDescPR(self, vrCPDescPR): self.vrCPDescPR = vrCPDescPR
    def get_vrCPNRet(self): return self.vrCPNRet
    def set_vrCPNRet(self, vrCPNRet): self.vrCPNRet = vrCPNRet
    def get_vrRatNRet(self): return self.vrRatNRet
    def set_vrRatNRet(self, vrRatNRet): self.vrRatNRet = vrRatNRet
    def get_vrSenarNRet(self): return self.vrSenarNRet
    def set_vrSenarNRet(self, vrSenarNRet): self.vrSenarNRet = vrSenarNRet
    def get_vrCPCalcPR(self): return self.vrCPCalcPR
    def set_vrCPCalcPR(self, vrCPCalcPR): self.vrCPCalcPR = vrCPCalcPR
    def get_vrRatDescPR(self): return self.vrRatDescPR
    def set_vrRatDescPR(self, vrRatDescPR): self.vrRatDescPR = vrRatDescPR
    def get_vrRatCalcPR(self): return self.vrRatCalcPR
    def set_vrRatCalcPR(self, vrRatCalcPR): self.vrRatCalcPR = vrRatCalcPR
    def get_vrSenarDesc(self): return self.vrSenarDesc
    def set_vrSenarDesc(self, vrSenarDesc): self.vrSenarDesc = vrSenarDesc
    def get_vrSenarCalc(self): return self.vrSenarCalc
    def set_vrSenarCalc(self, vrSenarCalc): self.vrSenarCalc = vrSenarCalc
    def hasContent_(self):
        if (
            self.indAquis is not None or
            self.vlrAquis is not None or
            self.vrCPDescPR is not None or
            self.vrCPNRet is not None or
            self.vrRatNRet is not None or
            self.vrSenarNRet is not None or
            self.vrCPCalcPR is not None or
            self.vrRatDescPR is not None or
            self.vrRatCalcPR is not None or
            self.vrSenarDesc is not None or
            self.vrSenarCalc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='basesAquis', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesAquis')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='basesAquis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='basesAquis', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='basesAquis'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='basesAquis', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indAquis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindAquis>%s</%sindAquis>%s' % (namespace_, self.gds_format_integer(self.indAquis, input_name='indAquis'), namespace_, eol_))
        if self.vlrAquis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svlrAquis>%s</%svlrAquis>%s' % (namespace_, self.gds_format_float(self.vlrAquis, input_name='vlrAquis'), namespace_, eol_))
        if self.vrCPDescPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCPDescPR>%s</%svrCPDescPR>%s' % (namespace_, self.gds_format_float(self.vrCPDescPR, input_name='vrCPDescPR'), namespace_, eol_))
        if self.vrCPNRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCPNRet>%s</%svrCPNRet>%s' % (namespace_, self.gds_format_float(self.vrCPNRet, input_name='vrCPNRet'), namespace_, eol_))
        if self.vrRatNRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrRatNRet>%s</%svrRatNRet>%s' % (namespace_, self.gds_format_float(self.vrRatNRet, input_name='vrRatNRet'), namespace_, eol_))
        if self.vrSenarNRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSenarNRet>%s</%svrSenarNRet>%s' % (namespace_, self.gds_format_float(self.vrSenarNRet, input_name='vrSenarNRet'), namespace_, eol_))
        if self.vrCPCalcPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCPCalcPR>%s</%svrCPCalcPR>%s' % (namespace_, self.gds_format_float(self.vrCPCalcPR, input_name='vrCPCalcPR'), namespace_, eol_))
        if self.vrRatDescPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrRatDescPR>%s</%svrRatDescPR>%s' % (namespace_, self.gds_format_float(self.vrRatDescPR, input_name='vrRatDescPR'), namespace_, eol_))
        if self.vrRatCalcPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrRatCalcPR>%s</%svrRatCalcPR>%s' % (namespace_, self.gds_format_float(self.vrRatCalcPR, input_name='vrRatCalcPR'), namespace_, eol_))
        if self.vrSenarDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSenarDesc>%s</%svrSenarDesc>%s' % (namespace_, self.gds_format_float(self.vrSenarDesc, input_name='vrSenarDesc'), namespace_, eol_))
        if self.vrSenarCalc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSenarCalc>%s</%svrSenarCalc>%s' % (namespace_, self.gds_format_float(self.vrSenarCalc, input_name='vrSenarCalc'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indAquis':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indAquis')
            self.indAquis = ival_
        elif nodeName_ == 'vlrAquis':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vlrAquis')
            self.vlrAquis = fval_
        elif nodeName_ == 'vrCPDescPR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCPDescPR')
            self.vrCPDescPR = fval_
        elif nodeName_ == 'vrCPNRet':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCPNRet')
            self.vrCPNRet = fval_
        elif nodeName_ == 'vrRatNRet':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRatNRet')
            self.vrRatNRet = fval_
        elif nodeName_ == 'vrSenarNRet':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSenarNRet')
            self.vrSenarNRet = fval_
        elif nodeName_ == 'vrCPCalcPR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCPCalcPR')
            self.vrCPCalcPR = fval_
        elif nodeName_ == 'vrRatDescPR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRatDescPR')
            self.vrRatDescPR = fval_
        elif nodeName_ == 'vrRatCalcPR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRatCalcPR')
            self.vrRatCalcPR = fval_
        elif nodeName_ == 'vrSenarDesc':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSenarDesc')
            self.vrSenarDesc = fval_
        elif nodeName_ == 'vrSenarCalc':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSenarCalc')
            self.vrSenarCalc = fval_
# end class basesAquis


class indAquis(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indAquis)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indAquis.subclass:
            return indAquis.subclass(*args_, **kwargs_)
        else:
            return indAquis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indAquis', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indAquis')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indAquis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indAquis', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indAquis'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indAquis', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indAquis


class vlrAquis(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vlrAquis)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vlrAquis.subclass:
            return vlrAquis.subclass(*args_, **kwargs_)
        else:
            return vlrAquis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vlrAquis', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vlrAquis')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vlrAquis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vlrAquis', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vlrAquis'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vlrAquis', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vlrAquis


class vrCPDescPR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrCPDescPR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrCPDescPR.subclass:
            return vrCPDescPR.subclass(*args_, **kwargs_)
        else:
            return vrCPDescPR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrCPDescPR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrCPDescPR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrCPDescPR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrCPDescPR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrCPDescPR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrCPDescPR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrCPDescPR


class vrCPNRet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrCPNRet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrCPNRet.subclass:
            return vrCPNRet.subclass(*args_, **kwargs_)
        else:
            return vrCPNRet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrCPNRet', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrCPNRet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrCPNRet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrCPNRet', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrCPNRet'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrCPNRet', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrCPNRet


class vrRatNRet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrRatNRet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrRatNRet.subclass:
            return vrRatNRet.subclass(*args_, **kwargs_)
        else:
            return vrRatNRet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrRatNRet', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrRatNRet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrRatNRet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrRatNRet', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrRatNRet'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrRatNRet', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrRatNRet


class vrSenarNRet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSenarNRet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSenarNRet.subclass:
            return vrSenarNRet.subclass(*args_, **kwargs_)
        else:
            return vrSenarNRet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSenarNRet', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSenarNRet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSenarNRet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSenarNRet', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSenarNRet'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSenarNRet', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSenarNRet


class vrCPCalcPR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrCPCalcPR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrCPCalcPR.subclass:
            return vrCPCalcPR.subclass(*args_, **kwargs_)
        else:
            return vrCPCalcPR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrCPCalcPR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrCPCalcPR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrCPCalcPR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrCPCalcPR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrCPCalcPR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrCPCalcPR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrCPCalcPR


class vrRatDescPR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrRatDescPR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrRatDescPR.subclass:
            return vrRatDescPR.subclass(*args_, **kwargs_)
        else:
            return vrRatDescPR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrRatDescPR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrRatDescPR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrRatDescPR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrRatDescPR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrRatDescPR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrRatDescPR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrRatDescPR


class vrRatCalcPR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrRatCalcPR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrRatCalcPR.subclass:
            return vrRatCalcPR.subclass(*args_, **kwargs_)
        else:
            return vrRatCalcPR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrRatCalcPR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrRatCalcPR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrRatCalcPR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrRatCalcPR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrRatCalcPR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrRatCalcPR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrRatCalcPR


class vrSenarDesc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSenarDesc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSenarDesc.subclass:
            return vrSenarDesc.subclass(*args_, **kwargs_)
        else:
            return vrSenarDesc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSenarDesc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSenarDesc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSenarDesc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSenarDesc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSenarDesc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSenarDesc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSenarDesc


class vrSenarCalc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSenarCalc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSenarCalc.subclass:
            return vrSenarCalc.subclass(*args_, **kwargs_)
        else:
            return vrSenarCalc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSenarCalc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSenarCalc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSenarCalc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSenarCalc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSenarCalc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSenarCalc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSenarCalc


class basesComerc(GeneratedsSuper):
    """Informações de bases de cálculo relativas à comercialização da
    produção rural da Pessoa Física. Informações desse grupo
    conforme informado pelo contribuinte em S-1260."""
    subclass = None
    superclass = None
    def __init__(self, indComerc=None, vrBcComPR=None, vrCPSusp=None, vrRatSusp=None, vrSenarSusp=None):
        self.original_tagname_ = None
        self.indComerc = indComerc
        self.vrBcComPR = vrBcComPR
        self.vrCPSusp = vrCPSusp
        self.vrRatSusp = vrRatSusp
        self.vrSenarSusp = vrSenarSusp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesComerc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesComerc.subclass:
            return basesComerc.subclass(*args_, **kwargs_)
        else:
            return basesComerc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indComerc(self): return self.indComerc
    def set_indComerc(self, indComerc): self.indComerc = indComerc
    def get_vrBcComPR(self): return self.vrBcComPR
    def set_vrBcComPR(self, vrBcComPR): self.vrBcComPR = vrBcComPR
    def get_vrCPSusp(self): return self.vrCPSusp
    def set_vrCPSusp(self, vrCPSusp): self.vrCPSusp = vrCPSusp
    def get_vrRatSusp(self): return self.vrRatSusp
    def set_vrRatSusp(self, vrRatSusp): self.vrRatSusp = vrRatSusp
    def get_vrSenarSusp(self): return self.vrSenarSusp
    def set_vrSenarSusp(self, vrSenarSusp): self.vrSenarSusp = vrSenarSusp
    def hasContent_(self):
        if (
            self.indComerc is not None or
            self.vrBcComPR is not None or
            self.vrCPSusp is not None or
            self.vrRatSusp is not None or
            self.vrSenarSusp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='basesComerc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesComerc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='basesComerc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='basesComerc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='basesComerc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='basesComerc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indComerc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindComerc>%s</%sindComerc>%s' % (namespace_, self.gds_format_integer(self.indComerc, input_name='indComerc'), namespace_, eol_))
        if self.vrBcComPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrBcComPR>%s</%svrBcComPR>%s' % (namespace_, self.gds_format_float(self.vrBcComPR, input_name='vrBcComPR'), namespace_, eol_))
        if self.vrCPSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCPSusp>%s</%svrCPSusp>%s' % (namespace_, self.gds_format_float(self.vrCPSusp, input_name='vrCPSusp'), namespace_, eol_))
        if self.vrRatSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrRatSusp>%s</%svrRatSusp>%s' % (namespace_, self.gds_format_float(self.vrRatSusp, input_name='vrRatSusp'), namespace_, eol_))
        if self.vrSenarSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSenarSusp>%s</%svrSenarSusp>%s' % (namespace_, self.gds_format_float(self.vrSenarSusp, input_name='vrSenarSusp'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indComerc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indComerc')
            self.indComerc = ival_
        elif nodeName_ == 'vrBcComPR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcComPR')
            self.vrBcComPR = fval_
        elif nodeName_ == 'vrCPSusp':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCPSusp')
            self.vrCPSusp = fval_
        elif nodeName_ == 'vrRatSusp':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRatSusp')
            self.vrRatSusp = fval_
        elif nodeName_ == 'vrSenarSusp':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSenarSusp')
            self.vrSenarSusp = fval_
# end class basesComerc


class indComerc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indComerc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indComerc.subclass:
            return indComerc.subclass(*args_, **kwargs_)
        else:
            return indComerc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indComerc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indComerc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indComerc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indComerc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indComerc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indComerc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indComerc


class vrBcComPR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrBcComPR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrBcComPR.subclass:
            return vrBcComPR.subclass(*args_, **kwargs_)
        else:
            return vrBcComPR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrBcComPR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrBcComPR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrBcComPR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrBcComPR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrBcComPR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrBcComPR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrBcComPR


class vrCPSusp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrCPSusp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrCPSusp.subclass:
            return vrCPSusp.subclass(*args_, **kwargs_)
        else:
            return vrCPSusp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrCPSusp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrCPSusp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrCPSusp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrCPSusp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrCPSusp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrCPSusp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrCPSusp


class vrRatSusp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrRatSusp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrRatSusp.subclass:
            return vrRatSusp.subclass(*args_, **kwargs_)
        else:
            return vrRatSusp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrRatSusp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrRatSusp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrRatSusp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrRatSusp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrRatSusp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrRatSusp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrRatSusp


class vrSenarSusp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSenarSusp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSenarSusp.subclass:
            return vrSenarSusp.subclass(*args_, **kwargs_)
        else:
            return vrSenarSusp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSenarSusp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSenarSusp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSenarSusp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSenarSusp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSenarSusp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSenarSusp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSenarSusp


class infoCREstab(GeneratedsSuper):
    """Informações das contribuições sociais devidas à Previdência Social e
    Outras Entidades e Fundos, consolidadas por estabelecimento e
    por código de Receita - CR."""
    subclass = None
    superclass = None
    def __init__(self, tpCR=None, vrCR=None, vrSuspCR=None):
        self.original_tagname_ = None
        self.tpCR = tpCR
        self.vrCR = vrCR
        self.vrSuspCR = vrSuspCR
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoCREstab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoCREstab.subclass:
            return infoCREstab.subclass(*args_, **kwargs_)
        else:
            return infoCREstab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpCR(self): return self.tpCR
    def set_tpCR(self, tpCR): self.tpCR = tpCR
    def get_vrCR(self): return self.vrCR
    def set_vrCR(self, vrCR): self.vrCR = vrCR
    def get_vrSuspCR(self): return self.vrSuspCR
    def set_vrSuspCR(self, vrSuspCR): self.vrSuspCR = vrSuspCR
    def hasContent_(self):
        if (
            self.tpCR is not None or
            self.vrCR is not None or
            self.vrSuspCR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoCREstab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoCREstab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoCREstab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoCREstab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoCREstab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoCREstab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpCR>%s</%stpCR>%s' % (namespace_, self.gds_format_integer(self.tpCR, input_name='tpCR'), namespace_, eol_))
        if self.vrCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCR>%s</%svrCR>%s' % (namespace_, self.gds_format_float(self.vrCR, input_name='vrCR'), namespace_, eol_))
        if self.vrSuspCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrSuspCR>%s</%svrSuspCR>%s' % (namespace_, self.gds_format_float(self.vrSuspCR, input_name='vrSuspCR'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpCR':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpCR')
            self.tpCR = ival_
        elif nodeName_ == 'vrCR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCR')
            self.vrCR = fval_
        elif nodeName_ == 'vrSuspCR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspCR')
            self.vrSuspCR = fval_
# end class infoCREstab


class tpCR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpCR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpCR.subclass:
            return tpCR.subclass(*args_, **kwargs_)
        else:
            return tpCR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpCR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpCR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpCR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpCR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpCR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpCR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpCR


class vrCR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrCR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrCR.subclass:
            return vrCR.subclass(*args_, **kwargs_)
        else:
            return vrCR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrCR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrCR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrCR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrCR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrCR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrCR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrCR


class vrSuspCR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrSuspCR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrSuspCR.subclass:
            return vrSuspCR.subclass(*args_, **kwargs_)
        else:
            return vrSuspCR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrSuspCR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrSuspCR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrSuspCR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrSuspCR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrSuspCR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrSuspCR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrSuspCR


class infoCRContrib(GeneratedsSuper):
    """Informações consolidadas das contribuições sociais devidas à
    Previdência Social e Outras Entidades e Fundos, por código de
    Receita - CR."""
    subclass = None
    superclass = None
    def __init__(self, tpCR=None, vrCR=None, vrCRSusp=None):
        self.original_tagname_ = None
        self.tpCR = tpCR
        self.vrCR = vrCR
        self.vrCRSusp = vrCRSusp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoCRContrib)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoCRContrib.subclass:
            return infoCRContrib.subclass(*args_, **kwargs_)
        else:
            return infoCRContrib(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpCR(self): return self.tpCR
    def set_tpCR(self, tpCR): self.tpCR = tpCR
    def get_vrCR(self): return self.vrCR
    def set_vrCR(self, vrCR): self.vrCR = vrCR
    def get_vrCRSusp(self): return self.vrCRSusp
    def set_vrCRSusp(self, vrCRSusp): self.vrCRSusp = vrCRSusp
    def hasContent_(self):
        if (
            self.tpCR is not None or
            self.vrCR is not None or
            self.vrCRSusp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoCRContrib', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoCRContrib')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoCRContrib')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoCRContrib', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoCRContrib'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoCRContrib', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpCR>%s</%stpCR>%s' % (namespace_, self.gds_format_integer(self.tpCR, input_name='tpCR'), namespace_, eol_))
        if self.vrCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCR>%s</%svrCR>%s' % (namespace_, self.gds_format_float(self.vrCR, input_name='vrCR'), namespace_, eol_))
        if self.vrCRSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrCRSusp>%s</%svrCRSusp>%s' % (namespace_, self.gds_format_float(self.vrCRSusp, input_name='vrCRSusp'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpCR':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpCR')
            self.tpCR = ival_
        elif nodeName_ == 'vrCR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCR')
            self.vrCR = fval_
        elif nodeName_ == 'vrCRSusp':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCRSusp')
            self.vrCRSusp = fval_
# end class infoCRContrib


class vrCRSusp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrCRSusp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrCRSusp.subclass:
            return vrCRSusp.subclass(*args_, **kwargs_)
        else:
            return vrCRSusp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrCRSusp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrCRSusp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrCRSusp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrCRSusp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrCRSusp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrCRSusp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrCRSusp


class TEmpregador(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEmpregador)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEmpregador.subclass:
            return TEmpregador.subclass(*args_, **kwargs_)
        else:
            return TEmpregador(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEmpregador', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEmpregador')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEmpregador')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEmpregador', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEmpregador'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEmpregador', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
# end class TEmpregador


GDSClassesMapping = {
    'ideEmpregador': TEmpregador,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from evtCS import *\n\n')
        sys.stdout.write('import evtCS as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "TEmpregador",
    "eSocial"
]
