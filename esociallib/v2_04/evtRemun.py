#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Oct 10 00:42:25 2017 by generateDS.py version 2.28b.
# Python 2.7.12 (default, Nov 19 2016, 06:48:10)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('--no-process-includes', '')
#   ('-o', 'esociallib/v2_04/evtRemun.py')
#
# Command line arguments:
#   schemas/v2_04/evtRemun.xsd
#
# Command line:
#   /usr/local/bin/generateDS --no-process-includes -o "esociallib/v2_04/evtRemun.py" schemas/v2_04/evtRemun.xsd
#
# Current working directory (os.getcwd()):
#   esociallib
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class eSocial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evtRemun=None, Signature=None):
        self.original_tagname_ = None
        self.evtRemun = evtRemun
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eSocial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eSocial.subclass:
            return eSocial.subclass(*args_, **kwargs_)
        else:
            return eSocial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evtRemun(self): return self.evtRemun
    def set_evtRemun(self, evtRemun): self.evtRemun = evtRemun
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def hasContent_(self):
        if (
            self.evtRemun is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eSocial', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eSocial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eSocial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eSocial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eSocial'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='eSocial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.evtRemun is not None:
            self.evtRemun.export(outfile, level, namespace_, name_='evtRemun', pretty_print=pretty_print)
        if self.Signature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSignature>%s</%sSignature>%s' % ('ds:', self.gds_encode(self.gds_format_string(quote_xml(self.Signature), input_name='Signature')), 'ds:', eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'evtRemun':
            obj_ = evtRemun.factory()
            obj_.build(child_)
            self.evtRemun = obj_
            obj_.original_tagname_ = 'evtRemun'
        elif nodeName_ == 'Signature':
            Signature_ = child_.text
            Signature_ = self.gds_validate_string(Signature_, node, 'Signature')
            self.Signature = Signature_
# end class eSocial


class evtRemun(GeneratedsSuper):
    """Evento remuneração de trabalhador vinculado ao Regime Geral de
    Previdência Social"""
    subclass = None
    superclass = None
    def __init__(self, Id=None, ideEvento=None, ideEmpregador=None, ideTrabalhador=None, dmDev=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.ideEvento = ideEvento
        self.ideEmpregador = ideEmpregador
        self.ideTrabalhador = ideTrabalhador
        if dmDev is None:
            self.dmDev = []
        else:
            self.dmDev = dmDev
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, evtRemun)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if evtRemun.subclass:
            return evtRemun.subclass(*args_, **kwargs_)
        else:
            return evtRemun(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideEvento(self): return self.ideEvento
    def set_ideEvento(self, ideEvento): self.ideEvento = ideEvento
    def get_ideEmpregador(self): return self.ideEmpregador
    def set_ideEmpregador(self, ideEmpregador): self.ideEmpregador = ideEmpregador
    def get_ideTrabalhador(self): return self.ideTrabalhador
    def set_ideTrabalhador(self, ideTrabalhador): self.ideTrabalhador = ideTrabalhador
    def get_dmDev(self): return self.dmDev
    def set_dmDev(self, dmDev): self.dmDev = dmDev
    def add_dmDev(self, value): self.dmDev.append(value)
    def insert_dmDev_at(self, index, value): self.dmDev.insert(index, value)
    def replace_dmDev_at(self, index, value): self.dmDev[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.ideEvento is not None or
            self.ideEmpregador is not None or
            self.ideTrabalhador is not None or
            self.dmDev
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='evtRemun', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('evtRemun')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='evtRemun')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='evtRemun', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='evtRemun'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='evtRemun', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideEvento is not None:
            self.ideEvento.export(outfile, level, namespace_, name_='ideEvento', pretty_print=pretty_print)
        if self.ideEmpregador is not None:
            self.ideEmpregador.export(outfile, level, namespace_, name_='ideEmpregador', pretty_print=pretty_print)
        if self.ideTrabalhador is not None:
            self.ideTrabalhador.export(outfile, level, namespace_, name_='ideTrabalhador', pretty_print=pretty_print)
        for dmDev_ in self.dmDev:
            dmDev_.export(outfile, level, namespace_, name_='dmDev', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideEvento':
            obj_ = ideEvento.factory()
            obj_.build(child_)
            self.ideEvento = obj_
            obj_.original_tagname_ = 'ideEvento'
        elif nodeName_ == 'ideEmpregador':
            obj_ = TEmpregador.factory()
            obj_.build(child_)
            self.ideEmpregador = obj_
            obj_.original_tagname_ = 'ideEmpregador'
        elif nodeName_ == 'ideTrabalhador':
            obj_ = ideTrabalhador.factory()
            obj_.build(child_)
            self.ideTrabalhador = obj_
            obj_.original_tagname_ = 'ideTrabalhador'
        elif nodeName_ == 'dmDev':
            obj_ = dmDev.factory()
            obj_.build(child_)
            self.dmDev.append(obj_)
            obj_.original_tagname_ = 'dmDev'
# end class evtRemun


class ideEvento(GeneratedsSuper):
    """Informações de identificação do evento"""
    subclass = None
    superclass = None
    def __init__(self, indRetif=None, nrRecibo=None, indApuracao=None, perApur=None, tpAmb=None, procEmi=None, verProc=None):
        self.original_tagname_ = None
        self.indRetif = indRetif
        self.nrRecibo = nrRecibo
        self.indApuracao = indApuracao
        self.perApur = perApur
        self.tpAmb = tpAmb
        self.procEmi = procEmi
        self.verProc = verProc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideEvento)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideEvento.subclass:
            return ideEvento.subclass(*args_, **kwargs_)
        else:
            return ideEvento(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indRetif(self): return self.indRetif
    def set_indRetif(self, indRetif): self.indRetif = indRetif
    def get_nrRecibo(self): return self.nrRecibo
    def set_nrRecibo(self, nrRecibo): self.nrRecibo = nrRecibo
    def get_indApuracao(self): return self.indApuracao
    def set_indApuracao(self, indApuracao): self.indApuracao = indApuracao
    def get_perApur(self): return self.perApur
    def set_perApur(self, perApur): self.perApur = perApur
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_procEmi(self): return self.procEmi
    def set_procEmi(self, procEmi): self.procEmi = procEmi
    def get_verProc(self): return self.verProc
    def set_verProc(self, verProc): self.verProc = verProc
    def hasContent_(self):
        if (
            self.indRetif is not None or
            self.nrRecibo is not None or
            self.indApuracao is not None or
            self.perApur is not None or
            self.tpAmb is not None or
            self.procEmi is not None or
            self.verProc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideEvento', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideEvento')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideEvento')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideEvento', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideEvento'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideEvento', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indRetif is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindRetif>%s</%sindRetif>%s' % (namespace_, self.gds_format_integer(self.indRetif, input_name='indRetif'), namespace_, eol_))
        if self.nrRecibo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrRecibo>%s</%snrRecibo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrRecibo), input_name='nrRecibo')), namespace_, eol_))
        if self.indApuracao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindApuracao>%s</%sindApuracao>%s' % (namespace_, self.gds_format_integer(self.indApuracao, input_name='indApuracao'), namespace_, eol_))
        if self.perApur is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sperApur>%s</%sperApur>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.perApur), input_name='perApur')), namespace_, eol_))
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespace_, self.gds_format_integer(self.tpAmb, input_name='tpAmb'), namespace_, eol_))
        if self.procEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocEmi>%s</%sprocEmi>%s' % (namespace_, self.gds_format_integer(self.procEmi, input_name='procEmi'), namespace_, eol_))
        if self.verProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverProc>%s</%sverProc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.verProc), input_name='verProc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indRetif':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indRetif')
            self.indRetif = ival_
        elif nodeName_ == 'nrRecibo':
            nrRecibo_ = child_.text
            nrRecibo_ = self.gds_validate_string(nrRecibo_, node, 'nrRecibo')
            self.nrRecibo = nrRecibo_
        elif nodeName_ == 'indApuracao':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indApuracao')
            self.indApuracao = ival_
        elif nodeName_ == 'perApur':
            perApur_ = child_.text
            perApur_ = self.gds_validate_string(perApur_, node, 'perApur')
            self.perApur = perApur_
        elif nodeName_ == 'tpAmb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpAmb')
            self.tpAmb = ival_
        elif nodeName_ == 'procEmi':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'procEmi')
            self.procEmi = ival_
        elif nodeName_ == 'verProc':
            verProc_ = child_.text
            verProc_ = self.gds_validate_string(verProc_, node, 'verProc')
            self.verProc = verProc_
# end class ideEvento


class indRetif(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indRetif)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indRetif.subclass:
            return indRetif.subclass(*args_, **kwargs_)
        else:
            return indRetif(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indRetif', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indRetif')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indRetif')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indRetif', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indRetif'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indRetif', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indRetif


class nrRecibo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrRecibo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrRecibo.subclass:
            return nrRecibo.subclass(*args_, **kwargs_)
        else:
            return nrRecibo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrRecibo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrRecibo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrRecibo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrRecibo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrRecibo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrRecibo', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrRecibo


class indApuracao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indApuracao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indApuracao.subclass:
            return indApuracao.subclass(*args_, **kwargs_)
        else:
            return indApuracao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indApuracao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indApuracao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indApuracao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indApuracao', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indApuracao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indApuracao', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indApuracao


class perApur(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, perApur)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if perApur.subclass:
            return perApur.subclass(*args_, **kwargs_)
        else:
            return perApur(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='perApur', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('perApur')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='perApur')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='perApur', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='perApur'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='perApur', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class perApur


class tpAmb(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpAmb)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpAmb.subclass:
            return tpAmb.subclass(*args_, **kwargs_)
        else:
            return tpAmb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpAmb', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpAmb')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpAmb')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpAmb', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpAmb'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpAmb', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpAmb


class procEmi(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procEmi.subclass:
            return procEmi.subclass(*args_, **kwargs_)
        else:
            return procEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='procEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='procEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='procEmi', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='procEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procEmi', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class procEmi


class verProc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, verProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if verProc.subclass:
            return verProc.subclass(*args_, **kwargs_)
        else:
            return verProc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='verProc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('verProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='verProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='verProc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='verProc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='verProc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class verProc


class ideTrabalhador(GeneratedsSuper):
    """Registro que apresenta a identificação básica do trabalhador ao qual
    se refere o evento de remuneração."""
    subclass = None
    superclass = None
    def __init__(self, cpfTrab=None, nisTrab=None, infoMV=None, infoComplem=None, procJudTrab=None):
        self.original_tagname_ = None
        self.cpfTrab = cpfTrab
        self.nisTrab = nisTrab
        self.infoMV = infoMV
        self.infoComplem = infoComplem
        if procJudTrab is None:
            self.procJudTrab = []
        else:
            self.procJudTrab = procJudTrab
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideTrabalhador)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideTrabalhador.subclass:
            return ideTrabalhador.subclass(*args_, **kwargs_)
        else:
            return ideTrabalhador(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpfTrab(self): return self.cpfTrab
    def set_cpfTrab(self, cpfTrab): self.cpfTrab = cpfTrab
    def get_nisTrab(self): return self.nisTrab
    def set_nisTrab(self, nisTrab): self.nisTrab = nisTrab
    def get_infoMV(self): return self.infoMV
    def set_infoMV(self, infoMV): self.infoMV = infoMV
    def get_infoComplem(self): return self.infoComplem
    def set_infoComplem(self, infoComplem): self.infoComplem = infoComplem
    def get_procJudTrab(self): return self.procJudTrab
    def set_procJudTrab(self, procJudTrab): self.procJudTrab = procJudTrab
    def add_procJudTrab(self, value): self.procJudTrab.append(value)
    def insert_procJudTrab_at(self, index, value): self.procJudTrab.insert(index, value)
    def replace_procJudTrab_at(self, index, value): self.procJudTrab[index] = value
    def hasContent_(self):
        if (
            self.cpfTrab is not None or
            self.nisTrab is not None or
            self.infoMV is not None or
            self.infoComplem is not None or
            self.procJudTrab
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideTrabalhador', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideTrabalhador')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideTrabalhador')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideTrabalhador', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideTrabalhador'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideTrabalhador', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cpfTrab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpfTrab>%s</%scpfTrab>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cpfTrab), input_name='cpfTrab')), namespace_, eol_))
        if self.nisTrab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snisTrab>%s</%snisTrab>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nisTrab), input_name='nisTrab')), namespace_, eol_))
        if self.infoMV is not None:
            self.infoMV.export(outfile, level, namespace_, name_='infoMV', pretty_print=pretty_print)
        if self.infoComplem is not None:
            self.infoComplem.export(outfile, level, namespace_, name_='infoComplem', pretty_print=pretty_print)
        for procJudTrab_ in self.procJudTrab:
            procJudTrab_.export(outfile, level, namespace_, name_='procJudTrab', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cpfTrab':
            cpfTrab_ = child_.text
            cpfTrab_ = self.gds_validate_string(cpfTrab_, node, 'cpfTrab')
            self.cpfTrab = cpfTrab_
        elif nodeName_ == 'nisTrab':
            nisTrab_ = child_.text
            nisTrab_ = self.gds_validate_string(nisTrab_, node, 'nisTrab')
            self.nisTrab = nisTrab_
        elif nodeName_ == 'infoMV':
            obj_ = infoMV.factory()
            obj_.build(child_)
            self.infoMV = obj_
            obj_.original_tagname_ = 'infoMV'
        elif nodeName_ == 'infoComplem':
            obj_ = infoComplem.factory()
            obj_.build(child_)
            self.infoComplem = obj_
            obj_.original_tagname_ = 'infoComplem'
        elif nodeName_ == 'procJudTrab':
            obj_ = procJudTrab.factory()
            obj_.build(child_)
            self.procJudTrab.append(obj_)
            obj_.original_tagname_ = 'procJudTrab'
# end class ideTrabalhador


class cpfTrab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cpfTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cpfTrab.subclass:
            return cpfTrab.subclass(*args_, **kwargs_)
        else:
            return cpfTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cpfTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpfTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cpfTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cpfTrab', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cpfTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cpfTrab', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cpfTrab


class nisTrab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nisTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nisTrab.subclass:
            return nisTrab.subclass(*args_, **kwargs_)
        else:
            return nisTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nisTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nisTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nisTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nisTrab', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nisTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nisTrab', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nisTrab


class infoMV(GeneratedsSuper):
    """Registro preenchido exclusivamente em caso de trabalhador que possua
    outros vínculos/atividades para definição do limite do salário-
    de-contribuição e da alíquota a ser aplicada no desconto da
    contribuição previdenciária."""
    subclass = None
    superclass = None
    def __init__(self, indMV=None, remunOutrEmpr=None):
        self.original_tagname_ = None
        self.indMV = indMV
        if remunOutrEmpr is None:
            self.remunOutrEmpr = []
        else:
            self.remunOutrEmpr = remunOutrEmpr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoMV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoMV.subclass:
            return infoMV.subclass(*args_, **kwargs_)
        else:
            return infoMV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indMV(self): return self.indMV
    def set_indMV(self, indMV): self.indMV = indMV
    def get_remunOutrEmpr(self): return self.remunOutrEmpr
    def set_remunOutrEmpr(self, remunOutrEmpr): self.remunOutrEmpr = remunOutrEmpr
    def add_remunOutrEmpr(self, value): self.remunOutrEmpr.append(value)
    def insert_remunOutrEmpr_at(self, index, value): self.remunOutrEmpr.insert(index, value)
    def replace_remunOutrEmpr_at(self, index, value): self.remunOutrEmpr[index] = value
    def hasContent_(self):
        if (
            self.indMV is not None or
            self.remunOutrEmpr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoMV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoMV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoMV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoMV', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoMV'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoMV', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indMV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindMV>%s</%sindMV>%s' % (namespace_, self.gds_format_integer(self.indMV, input_name='indMV'), namespace_, eol_))
        for remunOutrEmpr_ in self.remunOutrEmpr:
            remunOutrEmpr_.export(outfile, level, namespace_, name_='remunOutrEmpr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indMV':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indMV')
            self.indMV = ival_
        elif nodeName_ == 'remunOutrEmpr':
            obj_ = TRemunOutrasEmpresas.factory()
            obj_.build(child_)
            self.remunOutrEmpr.append(obj_)
            obj_.original_tagname_ = 'remunOutrEmpr'
# end class infoMV


class indMV(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indMV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indMV.subclass:
            return indMV.subclass(*args_, **kwargs_)
        else:
            return indMV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indMV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indMV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indMV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indMV', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indMV'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indMV', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indMV


class infoComplem(GeneratedsSuper):
    """Registro preenchido exclusivamente quando o evento de remuneração
    referir-se a trabalhador cuja categoria não está sujeita ao
    evento de admissão ou ao evento de início de "trabalhador sem
    vínculo". No caso das categorias em que o envio do evento TSV é
    opcional, o preenchimento do grupo somente é exigido se não
    houver evento TSV Início correspondente (cpf + categoria). As
    informações complementares são necessárias para correta
    identificação do trabalhador (Nome, data de nascimento, etc)."""
    subclass = None
    superclass = None
    def __init__(self, nmTrab=None, dtNascto=None, codCBO=None, natAtividade=None, qtdDiasTrab=None, sucessaoVinc=None):
        self.original_tagname_ = None
        self.nmTrab = nmTrab
        if isinstance(dtNascto, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dtNascto, '%Y-%m-%d').date()
        else:
            initvalue_ = dtNascto
        self.dtNascto = initvalue_
        self.codCBO = codCBO
        self.natAtividade = natAtividade
        self.qtdDiasTrab = qtdDiasTrab
        self.sucessaoVinc = sucessaoVinc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoComplem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoComplem.subclass:
            return infoComplem.subclass(*args_, **kwargs_)
        else:
            return infoComplem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nmTrab(self): return self.nmTrab
    def set_nmTrab(self, nmTrab): self.nmTrab = nmTrab
    def get_dtNascto(self): return self.dtNascto
    def set_dtNascto(self, dtNascto): self.dtNascto = dtNascto
    def get_codCBO(self): return self.codCBO
    def set_codCBO(self, codCBO): self.codCBO = codCBO
    def get_natAtividade(self): return self.natAtividade
    def set_natAtividade(self, natAtividade): self.natAtividade = natAtividade
    def get_qtdDiasTrab(self): return self.qtdDiasTrab
    def set_qtdDiasTrab(self, qtdDiasTrab): self.qtdDiasTrab = qtdDiasTrab
    def get_sucessaoVinc(self): return self.sucessaoVinc
    def set_sucessaoVinc(self, sucessaoVinc): self.sucessaoVinc = sucessaoVinc
    def hasContent_(self):
        if (
            self.nmTrab is not None or
            self.dtNascto is not None or
            self.codCBO is not None or
            self.natAtividade is not None or
            self.qtdDiasTrab is not None or
            self.sucessaoVinc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoComplem', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoComplem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoComplem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoComplem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoComplem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoComplem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nmTrab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snmTrab>%s</%snmTrab>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nmTrab), input_name='nmTrab')), namespace_, eol_))
        if self.dtNascto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdtNascto>%s</%sdtNascto>%s' % (namespace_, self.gds_format_date(self.dtNascto, input_name='dtNascto'), namespace_, eol_))
        if self.codCBO is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodCBO>%s</%scodCBO>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codCBO), input_name='codCBO')), namespace_, eol_))
        if self.natAtividade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snatAtividade>%s</%snatAtividade>%s' % (namespace_, self.gds_format_integer(self.natAtividade, input_name='natAtividade'), namespace_, eol_))
        if self.qtdDiasTrab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtdDiasTrab>%s</%sqtdDiasTrab>%s' % (namespace_, self.gds_format_integer(self.qtdDiasTrab, input_name='qtdDiasTrab'), namespace_, eol_))
        if self.sucessaoVinc is not None:
            self.sucessaoVinc.export(outfile, level, namespace_, name_='sucessaoVinc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nmTrab':
            nmTrab_ = child_.text
            nmTrab_ = self.gds_validate_string(nmTrab_, node, 'nmTrab')
            self.nmTrab = nmTrab_
        elif nodeName_ == 'dtNascto':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dtNascto = dval_
        elif nodeName_ == 'codCBO':
            codCBO_ = child_.text
            codCBO_ = self.gds_validate_string(codCBO_, node, 'codCBO')
            self.codCBO = codCBO_
        elif nodeName_ == 'natAtividade':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'natAtividade')
            self.natAtividade = ival_
        elif nodeName_ == 'qtdDiasTrab':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'qtdDiasTrab')
            self.qtdDiasTrab = ival_
        elif nodeName_ == 'sucessaoVinc':
            obj_ = sucessaoVinc.factory()
            obj_.build(child_)
            self.sucessaoVinc = obj_
            obj_.original_tagname_ = 'sucessaoVinc'
# end class infoComplem


class nmTrab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nmTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nmTrab.subclass:
            return nmTrab.subclass(*args_, **kwargs_)
        else:
            return nmTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nmTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nmTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nmTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nmTrab', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nmTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nmTrab', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nmTrab


class dtNascto(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dtNascto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dtNascto.subclass:
            return dtNascto.subclass(*args_, **kwargs_)
        else:
            return dtNascto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dtNascto', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dtNascto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dtNascto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dtNascto', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dtNascto'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dtNascto', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dtNascto


class codCBO(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codCBO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codCBO.subclass:
            return codCBO.subclass(*args_, **kwargs_)
        else:
            return codCBO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codCBO', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codCBO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codCBO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codCBO', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codCBO'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codCBO', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codCBO


class natAtividade(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, natAtividade)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if natAtividade.subclass:
            return natAtividade.subclass(*args_, **kwargs_)
        else:
            return natAtividade(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='natAtividade', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('natAtividade')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='natAtividade')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='natAtividade', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='natAtividade'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='natAtividade', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class natAtividade


class qtdDiasTrab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qtdDiasTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qtdDiasTrab.subclass:
            return qtdDiasTrab.subclass(*args_, **kwargs_)
        else:
            return qtdDiasTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qtdDiasTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qtdDiasTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qtdDiasTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qtdDiasTrab', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qtdDiasTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qtdDiasTrab', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qtdDiasTrab


class sucessaoVinc(GeneratedsSuper):
    """Grupo de informações da sucessão de vínculo trabalhista/estatutário"""
    subclass = None
    superclass = None
    def __init__(self, cnpjEmpregAnt=None, matricAnt=None, dtAdm=None, observacao=None):
        self.original_tagname_ = None
        self.cnpjEmpregAnt = cnpjEmpregAnt
        self.matricAnt = matricAnt
        if isinstance(dtAdm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dtAdm, '%Y-%m-%d').date()
        else:
            initvalue_ = dtAdm
        self.dtAdm = initvalue_
        self.observacao = observacao
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sucessaoVinc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sucessaoVinc.subclass:
            return sucessaoVinc.subclass(*args_, **kwargs_)
        else:
            return sucessaoVinc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnpjEmpregAnt(self): return self.cnpjEmpregAnt
    def set_cnpjEmpregAnt(self, cnpjEmpregAnt): self.cnpjEmpregAnt = cnpjEmpregAnt
    def get_matricAnt(self): return self.matricAnt
    def set_matricAnt(self, matricAnt): self.matricAnt = matricAnt
    def get_dtAdm(self): return self.dtAdm
    def set_dtAdm(self, dtAdm): self.dtAdm = dtAdm
    def get_observacao(self): return self.observacao
    def set_observacao(self, observacao): self.observacao = observacao
    def hasContent_(self):
        if (
            self.cnpjEmpregAnt is not None or
            self.matricAnt is not None or
            self.dtAdm is not None or
            self.observacao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sucessaoVinc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sucessaoVinc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sucessaoVinc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sucessaoVinc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sucessaoVinc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sucessaoVinc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnpjEmpregAnt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scnpjEmpregAnt>%s</%scnpjEmpregAnt>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cnpjEmpregAnt), input_name='cnpjEmpregAnt')), namespace_, eol_))
        if self.matricAnt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smatricAnt>%s</%smatricAnt>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.matricAnt), input_name='matricAnt')), namespace_, eol_))
        if self.dtAdm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdtAdm>%s</%sdtAdm>%s' % (namespace_, self.gds_format_date(self.dtAdm, input_name='dtAdm'), namespace_, eol_))
        if self.observacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservacao>%s</%sobservacao>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.observacao), input_name='observacao')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnpjEmpregAnt':
            cnpjEmpregAnt_ = child_.text
            cnpjEmpregAnt_ = self.gds_validate_string(cnpjEmpregAnt_, node, 'cnpjEmpregAnt')
            self.cnpjEmpregAnt = cnpjEmpregAnt_
        elif nodeName_ == 'matricAnt':
            matricAnt_ = child_.text
            matricAnt_ = self.gds_validate_string(matricAnt_, node, 'matricAnt')
            self.matricAnt = matricAnt_
        elif nodeName_ == 'dtAdm':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dtAdm = dval_
        elif nodeName_ == 'observacao':
            observacao_ = child_.text
            observacao_ = self.gds_validate_string(observacao_, node, 'observacao')
            self.observacao = observacao_
# end class sucessaoVinc


class cnpjEmpregAnt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cnpjEmpregAnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cnpjEmpregAnt.subclass:
            return cnpjEmpregAnt.subclass(*args_, **kwargs_)
        else:
            return cnpjEmpregAnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cnpjEmpregAnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cnpjEmpregAnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cnpjEmpregAnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cnpjEmpregAnt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cnpjEmpregAnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cnpjEmpregAnt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cnpjEmpregAnt


class matricAnt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, matricAnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if matricAnt.subclass:
            return matricAnt.subclass(*args_, **kwargs_)
        else:
            return matricAnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='matricAnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('matricAnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matricAnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='matricAnt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='matricAnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='matricAnt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class matricAnt


class dtAdm(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dtAdm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dtAdm.subclass:
            return dtAdm.subclass(*args_, **kwargs_)
        else:
            return dtAdm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dtAdm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dtAdm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dtAdm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dtAdm', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dtAdm'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dtAdm', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dtAdm


class observacao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, observacao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if observacao.subclass:
            return observacao.subclass(*args_, **kwargs_)
        else:
            return observacao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='observacao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('observacao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='observacao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='observacao', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='observacao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='observacao', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class observacao


class procJudTrab(GeneratedsSuper):
    """Informações sobre a existência de processos judiciais do trabalhador
    com decisão favorável quanto à não incidência ou alterações na
    incidência de contribuições sociais e/ou Imposto de Renda sobre
    as rubricas apresentadas nos subregistros de {dmDev}."""
    subclass = None
    superclass = None
    def __init__(self, tpTrib=None, nrProcJud=None, codSusp=None):
        self.original_tagname_ = None
        self.tpTrib = tpTrib
        self.nrProcJud = nrProcJud
        self.codSusp = codSusp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procJudTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procJudTrab.subclass:
            return procJudTrab.subclass(*args_, **kwargs_)
        else:
            return procJudTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpTrib(self): return self.tpTrib
    def set_tpTrib(self, tpTrib): self.tpTrib = tpTrib
    def get_nrProcJud(self): return self.nrProcJud
    def set_nrProcJud(self, nrProcJud): self.nrProcJud = nrProcJud
    def get_codSusp(self): return self.codSusp
    def set_codSusp(self, codSusp): self.codSusp = codSusp
    def hasContent_(self):
        if (
            self.tpTrib is not None or
            self.nrProcJud is not None or
            self.codSusp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='procJudTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procJudTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='procJudTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='procJudTrab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='procJudTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procJudTrab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpTrib>%s</%stpTrib>%s' % (namespace_, self.gds_format_integer(self.tpTrib, input_name='tpTrib'), namespace_, eol_))
        if self.nrProcJud is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrProcJud>%s</%snrProcJud>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrProcJud), input_name='nrProcJud')), namespace_, eol_))
        if self.codSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodSusp>%s</%scodSusp>%s' % (namespace_, self.gds_format_integer(self.codSusp, input_name='codSusp'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpTrib':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpTrib')
            self.tpTrib = ival_
        elif nodeName_ == 'nrProcJud':
            nrProcJud_ = child_.text
            nrProcJud_ = self.gds_validate_string(nrProcJud_, node, 'nrProcJud')
            self.nrProcJud = nrProcJud_
        elif nodeName_ == 'codSusp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codSusp')
            self.codSusp = ival_
# end class procJudTrab


class tpTrib(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpTrib)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpTrib.subclass:
            return tpTrib.subclass(*args_, **kwargs_)
        else:
            return tpTrib(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpTrib', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpTrib')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpTrib')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpTrib', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpTrib'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpTrib', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpTrib


class nrProcJud(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrProcJud)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrProcJud.subclass:
            return nrProcJud.subclass(*args_, **kwargs_)
        else:
            return nrProcJud(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrProcJud', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrProcJud')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrProcJud')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrProcJud', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrProcJud'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrProcJud', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrProcJud


class codSusp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codSusp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codSusp.subclass:
            return codSusp.subclass(*args_, **kwargs_)
        else:
            return codSusp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codSusp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codSusp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codSusp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codSusp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codSusp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codSusp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codSusp


class dmDev(GeneratedsSuper):
    """Identificação de cada um dos demonstrativos de valores devidos ao
    trabalhador antes das retenções de pensão alimentícia e IRRF.
    (As retenções de pensão alimentícia e IRRF devem ser realizadas
    no ato do pagamento e, portanto, são informadas no evento
    S-1210). Para as rubricas cujo {codIncCP} = [31, 32, 34, 35], o
    somatório do valor das rubricas cujo ({tpRubr} = [2,4]) deverá
    ser maior ou igual ao somatório do valor das rubricas cujo
    ({tpRubr} = [1,3]), considerando cada um dos códigos {codIncCP}
    individualmente. O somatório dos Vencimentos deve ser maior ou
    igual ao somatório dos Descontos. As informações dos campos
    {ideEstabLot/nrInsc}, {detVerbas/codRubr},
    {ideEstabLot/codLotacao} vinculadas a este registro, devem
    constar nas respectivas tabelas S-1005, S-1010 e S-1020, no mês
    informado em: a) {perApur} se as informações pertencerem ao
    grupo {infoPerApur}; b) {perRef} se as informações pertencerem
    ao grupo {infoPerAnt}."""
    subclass = None
    superclass = None
    def __init__(self, ideDmDev=None, codCateg=None, infoPerApur=None, infoPerAnt=None, infoTrabInterm=None):
        self.original_tagname_ = None
        self.ideDmDev = ideDmDev
        self.codCateg = codCateg
        self.infoPerApur = infoPerApur
        self.infoPerAnt = infoPerAnt
        if infoTrabInterm is None:
            self.infoTrabInterm = []
        else:
            self.infoTrabInterm = infoTrabInterm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dmDev)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dmDev.subclass:
            return dmDev.subclass(*args_, **kwargs_)
        else:
            return dmDev(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideDmDev(self): return self.ideDmDev
    def set_ideDmDev(self, ideDmDev): self.ideDmDev = ideDmDev
    def get_codCateg(self): return self.codCateg
    def set_codCateg(self, codCateg): self.codCateg = codCateg
    def get_infoPerApur(self): return self.infoPerApur
    def set_infoPerApur(self, infoPerApur): self.infoPerApur = infoPerApur
    def get_infoPerAnt(self): return self.infoPerAnt
    def set_infoPerAnt(self, infoPerAnt): self.infoPerAnt = infoPerAnt
    def get_infoTrabInterm(self): return self.infoTrabInterm
    def set_infoTrabInterm(self, infoTrabInterm): self.infoTrabInterm = infoTrabInterm
    def add_infoTrabInterm(self, value): self.infoTrabInterm.append(value)
    def insert_infoTrabInterm_at(self, index, value): self.infoTrabInterm.insert(index, value)
    def replace_infoTrabInterm_at(self, index, value): self.infoTrabInterm[index] = value
    def hasContent_(self):
        if (
            self.ideDmDev is not None or
            self.codCateg is not None or
            self.infoPerApur is not None or
            self.infoPerAnt is not None or
            self.infoTrabInterm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dmDev', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dmDev')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dmDev')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dmDev', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dmDev'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dmDev', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideDmDev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sideDmDev>%s</%sideDmDev>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ideDmDev), input_name='ideDmDev')), namespace_, eol_))
        if self.codCateg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodCateg>%s</%scodCateg>%s' % (namespace_, self.gds_format_integer(self.codCateg, input_name='codCateg'), namespace_, eol_))
        if self.infoPerApur is not None:
            self.infoPerApur.export(outfile, level, namespace_, name_='infoPerApur', pretty_print=pretty_print)
        if self.infoPerAnt is not None:
            self.infoPerAnt.export(outfile, level, namespace_, name_='infoPerAnt', pretty_print=pretty_print)
        for infoTrabInterm_ in self.infoTrabInterm:
            infoTrabInterm_.export(outfile, level, namespace_, name_='infoTrabInterm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideDmDev':
            ideDmDev_ = child_.text
            ideDmDev_ = self.gds_validate_string(ideDmDev_, node, 'ideDmDev')
            self.ideDmDev = ideDmDev_
        elif nodeName_ == 'codCateg':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codCateg')
            self.codCateg = ival_
        elif nodeName_ == 'infoPerApur':
            obj_ = infoPerApur.factory()
            obj_.build(child_)
            self.infoPerApur = obj_
            obj_.original_tagname_ = 'infoPerApur'
        elif nodeName_ == 'infoPerAnt':
            obj_ = infoPerAnt.factory()
            obj_.build(child_)
            self.infoPerAnt = obj_
            obj_.original_tagname_ = 'infoPerAnt'
        elif nodeName_ == 'infoTrabInterm':
            obj_ = infoTrabInterm.factory()
            obj_.build(child_)
            self.infoTrabInterm.append(obj_)
            obj_.original_tagname_ = 'infoTrabInterm'
# end class dmDev


class ideDmDev(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideDmDev)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideDmDev.subclass:
            return ideDmDev.subclass(*args_, **kwargs_)
        else:
            return ideDmDev(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideDmDev', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideDmDev')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideDmDev')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideDmDev', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideDmDev'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideDmDev', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ideDmDev


class codCateg(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codCateg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codCateg.subclass:
            return codCateg.subclass(*args_, **kwargs_)
        else:
            return codCateg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codCateg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codCateg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codCateg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codCateg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codCateg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codCateg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codCateg


class infoPerApur(GeneratedsSuper):
    """Remuneração no período de apuração"""
    subclass = None
    superclass = None
    def __init__(self, ideEstabLot=None):
        self.original_tagname_ = None
        if ideEstabLot is None:
            self.ideEstabLot = []
        else:
            self.ideEstabLot = ideEstabLot
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoPerApur)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoPerApur.subclass:
            return infoPerApur.subclass(*args_, **kwargs_)
        else:
            return infoPerApur(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideEstabLot(self): return self.ideEstabLot
    def set_ideEstabLot(self, ideEstabLot): self.ideEstabLot = ideEstabLot
    def add_ideEstabLot(self, value): self.ideEstabLot.append(value)
    def insert_ideEstabLot_at(self, index, value): self.ideEstabLot.insert(index, value)
    def replace_ideEstabLot_at(self, index, value): self.ideEstabLot[index] = value
    def hasContent_(self):
        if (
            self.ideEstabLot
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoPerApur', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoPerApur')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoPerApur')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoPerApur', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoPerApur'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoPerApur', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ideEstabLot_ in self.ideEstabLot:
            ideEstabLot_.export(outfile, level, namespace_, name_='ideEstabLot', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideEstabLot':
            obj_ = ideEstabLot.factory()
            obj_.build(child_)
            self.ideEstabLot.append(obj_)
            obj_.original_tagname_ = 'ideEstabLot'
# end class infoPerApur


class ideEstabLot(GeneratedsSuper):
    """Registro que identifica o Estabelecimento/Lotação no qual o
    trabalhador possui remuneração no período de apuração. O
    estabelecimento identificado no registro pode ser: o número do
    CNPJ do estabelecimento da própria empresa (matriz/filial), o
    número da obra (própria) no CNO, ou o número do CAEPF (no caso
    de pessoa física obrigada a inscrição no cadastro de atividades
    econômicas da pessoa física). No caso específico do trabalhador
    doméstico, o estabelecimento deve ser o próprio CPF do
    empregador."""
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None, codLotacao=None, qtdDiasAv=None, remunPerApur=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
        self.codLotacao = codLotacao
        self.qtdDiasAv = qtdDiasAv
        if remunPerApur is None:
            self.remunPerApur = []
        else:
            self.remunPerApur = remunPerApur
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideEstabLot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideEstabLot.subclass:
            return ideEstabLot.subclass(*args_, **kwargs_)
        else:
            return ideEstabLot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def get_codLotacao(self): return self.codLotacao
    def set_codLotacao(self, codLotacao): self.codLotacao = codLotacao
    def get_qtdDiasAv(self): return self.qtdDiasAv
    def set_qtdDiasAv(self, qtdDiasAv): self.qtdDiasAv = qtdDiasAv
    def get_remunPerApur(self): return self.remunPerApur
    def set_remunPerApur(self, remunPerApur): self.remunPerApur = remunPerApur
    def add_remunPerApur(self, value): self.remunPerApur.append(value)
    def insert_remunPerApur_at(self, index, value): self.remunPerApur.insert(index, value)
    def replace_remunPerApur_at(self, index, value): self.remunPerApur[index] = value
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None or
            self.codLotacao is not None or
            self.qtdDiasAv is not None or
            self.remunPerApur
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideEstabLot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideEstabLot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideEstabLot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideEstabLot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideEstabLot'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideEstabLot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
        if self.codLotacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodLotacao>%s</%scodLotacao>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codLotacao), input_name='codLotacao')), namespace_, eol_))
        if self.qtdDiasAv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtdDiasAv>%s</%sqtdDiasAv>%s' % (namespace_, self.gds_format_integer(self.qtdDiasAv, input_name='qtdDiasAv'), namespace_, eol_))
        for remunPerApur_ in self.remunPerApur:
            remunPerApur_.export(outfile, level, namespace_, name_='remunPerApur', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
        elif nodeName_ == 'codLotacao':
            codLotacao_ = child_.text
            codLotacao_ = self.gds_validate_string(codLotacao_, node, 'codLotacao')
            self.codLotacao = codLotacao_
        elif nodeName_ == 'qtdDiasAv':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'qtdDiasAv')
            self.qtdDiasAv = ival_
        elif nodeName_ == 'remunPerApur':
            obj_ = remunPerApur.factory()
            obj_.build(child_)
            self.remunPerApur.append(obj_)
            obj_.original_tagname_ = 'remunPerApur'
# end class ideEstabLot


class tpInsc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpInsc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpInsc.subclass:
            return tpInsc.subclass(*args_, **kwargs_)
        else:
            return tpInsc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpInsc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpInsc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpInsc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpInsc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpInsc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpInsc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpInsc


class nrInsc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrInsc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrInsc.subclass:
            return nrInsc.subclass(*args_, **kwargs_)
        else:
            return nrInsc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrInsc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrInsc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrInsc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrInsc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrInsc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrInsc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrInsc


class codLotacao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codLotacao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codLotacao.subclass:
            return codLotacao.subclass(*args_, **kwargs_)
        else:
            return codLotacao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codLotacao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codLotacao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codLotacao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codLotacao', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codLotacao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codLotacao', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codLotacao


class qtdDiasAv(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qtdDiasAv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qtdDiasAv.subclass:
            return qtdDiasAv.subclass(*args_, **kwargs_)
        else:
            return qtdDiasAv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qtdDiasAv', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qtdDiasAv')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qtdDiasAv')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qtdDiasAv', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qtdDiasAv'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qtdDiasAv', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qtdDiasAv


class remunPerApur(GeneratedsSuper):
    """Informações relativas a remuneração do trabalhador no período de
    apuração"""
    subclass = None
    superclass = None
    def __init__(self, matricula=None, indSimples=None, itensRemun=None, infoSaudeColet=None, infoAgNocivo=None):
        self.original_tagname_ = None
        self.matricula = matricula
        self.indSimples = indSimples
        if itensRemun is None:
            self.itensRemun = []
        else:
            self.itensRemun = itensRemun
        self.infoSaudeColet = infoSaudeColet
        self.infoAgNocivo = infoAgNocivo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remunPerApur)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remunPerApur.subclass:
            return remunPerApur.subclass(*args_, **kwargs_)
        else:
            return remunPerApur(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matricula(self): return self.matricula
    def set_matricula(self, matricula): self.matricula = matricula
    def get_indSimples(self): return self.indSimples
    def set_indSimples(self, indSimples): self.indSimples = indSimples
    def get_itensRemun(self): return self.itensRemun
    def set_itensRemun(self, itensRemun): self.itensRemun = itensRemun
    def add_itensRemun(self, value): self.itensRemun.append(value)
    def insert_itensRemun_at(self, index, value): self.itensRemun.insert(index, value)
    def replace_itensRemun_at(self, index, value): self.itensRemun[index] = value
    def get_infoSaudeColet(self): return self.infoSaudeColet
    def set_infoSaudeColet(self, infoSaudeColet): self.infoSaudeColet = infoSaudeColet
    def get_infoAgNocivo(self): return self.infoAgNocivo
    def set_infoAgNocivo(self, infoAgNocivo): self.infoAgNocivo = infoAgNocivo
    def hasContent_(self):
        if (
            self.matricula is not None or
            self.indSimples is not None or
            self.itensRemun or
            self.infoSaudeColet is not None or
            self.infoAgNocivo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='remunPerApur', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remunPerApur')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remunPerApur')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='remunPerApur', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='remunPerApur'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='remunPerApur', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.matricula is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smatricula>%s</%smatricula>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.matricula), input_name='matricula')), namespace_, eol_))
        if self.indSimples is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSimples>%s</%sindSimples>%s' % (namespace_, self.gds_format_integer(self.indSimples, input_name='indSimples'), namespace_, eol_))
        for itensRemun_ in self.itensRemun:
            itensRemun_.export(outfile, level, namespace_, name_='itensRemun', pretty_print=pretty_print)
        if self.infoSaudeColet is not None:
            self.infoSaudeColet.export(outfile, level, namespace_, name_='infoSaudeColet', pretty_print=pretty_print)
        if self.infoAgNocivo is not None:
            self.infoAgNocivo.export(outfile, level, namespace_, name_='infoAgNocivo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'matricula':
            matricula_ = child_.text
            matricula_ = self.gds_validate_string(matricula_, node, 'matricula')
            self.matricula = matricula_
        elif nodeName_ == 'indSimples':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indSimples')
            self.indSimples = ival_
        elif nodeName_ == 'itensRemun':
            obj_ = TItemRemuneracao.factory()
            obj_.build(child_)
            self.itensRemun.append(obj_)
            obj_.original_tagname_ = 'itensRemun'
        elif nodeName_ == 'infoSaudeColet':
            obj_ = TSaudeCol.factory()
            obj_.build(child_)
            self.infoSaudeColet = obj_
            obj_.original_tagname_ = 'infoSaudeColet'
        elif nodeName_ == 'infoAgNocivo':
            obj_ = infoAgNocivo.factory()
            obj_.build(child_)
            self.infoAgNocivo = obj_
            obj_.original_tagname_ = 'infoAgNocivo'
# end class remunPerApur


class matricula(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, matricula)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if matricula.subclass:
            return matricula.subclass(*args_, **kwargs_)
        else:
            return matricula(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='matricula', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('matricula')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matricula')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='matricula', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='matricula'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='matricula', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class matricula


class indSimples(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indSimples)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indSimples.subclass:
            return indSimples.subclass(*args_, **kwargs_)
        else:
            return indSimples(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indSimples', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indSimples')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indSimples')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indSimples', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indSimples'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indSimples', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indSimples


class infoAgNocivo(GeneratedsSuper):
    """Registro preenchido exclusivamente em relação a remuneração de
    trabalhador enquadrado em uma das categorias relativas a
    Empregado, Servidor Público, Avulso, ou na categoria de
    Cooperado filiado a cooperativa de produção [738] ou Cooperado
    filiado a cooperativa de trabalho que presta serviço a empresa
    [731, 734], permitindo o detalhamento do grau de exposição do
    trabalhador aos agentes nocivos que ensejam a cobrança da
    contribuição adicional para financiamento dos benefícios de
    aposentadoria especial."""
    subclass = None
    superclass = None
    def __init__(self, grauExp=None):
        self.original_tagname_ = None
        self.grauExp = grauExp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoAgNocivo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoAgNocivo.subclass:
            return infoAgNocivo.subclass(*args_, **kwargs_)
        else:
            return infoAgNocivo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_grauExp(self): return self.grauExp
    def set_grauExp(self, grauExp): self.grauExp = grauExp
    def hasContent_(self):
        if (
            self.grauExp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoAgNocivo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoAgNocivo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoAgNocivo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoAgNocivo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoAgNocivo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoAgNocivo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.grauExp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgrauExp>%s</%sgrauExp>%s' % (namespace_, self.gds_format_integer(self.grauExp, input_name='grauExp'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'grauExp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'grauExp')
            self.grauExp = ival_
# end class infoAgNocivo


class grauExp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, grauExp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if grauExp.subclass:
            return grauExp.subclass(*args_, **kwargs_)
        else:
            return grauExp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='grauExp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('grauExp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='grauExp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='grauExp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='grauExp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='grauExp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class grauExp


class infoPerAnt(GeneratedsSuper):
    """Registro destinado ao registro de: a) remuneração relativa a
    diferenças salariais provenientes de acordos coletivos,
    convenção coletiva e dissídio; b) remuneração relativa a
    diferenças de vencimento provenientes de disposições legais
    (órgãos públicos); c) bases de cálculo para efeitos de apuração
    de FGTS resultantes de conversão de licença saúde em acidente de
    trabalho. d) verbas de natureza salarial ou não salarial devidas
    após o desligamento. OBS.: as informações previstas nos itens
    "a", "b" e "d" acima podem se referir ao período de apuração
    definido em {perApur} ou a períodos anteriores a {perApur}."""
    subclass = None
    superclass = None
    def __init__(self, ideADC=None):
        self.original_tagname_ = None
        if ideADC is None:
            self.ideADC = []
        else:
            self.ideADC = ideADC
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoPerAnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoPerAnt.subclass:
            return infoPerAnt.subclass(*args_, **kwargs_)
        else:
            return infoPerAnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideADC(self): return self.ideADC
    def set_ideADC(self, ideADC): self.ideADC = ideADC
    def add_ideADC(self, value): self.ideADC.append(value)
    def insert_ideADC_at(self, index, value): self.ideADC.insert(index, value)
    def replace_ideADC_at(self, index, value): self.ideADC[index] = value
    def hasContent_(self):
        if (
            self.ideADC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoPerAnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoPerAnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoPerAnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoPerAnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoPerAnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoPerAnt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ideADC_ in self.ideADC:
            ideADC_.export(outfile, level, namespace_, name_='ideADC', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideADC':
            obj_ = ideADC.factory()
            obj_.build(child_)
            self.ideADC.append(obj_)
            obj_.original_tagname_ = 'ideADC'
# end class infoPerAnt


class ideADC(GeneratedsSuper):
    """Identificação do Instrumento ou situação ensejadora da remuneração
    relativa a Períodos de Apuração Anteriores."""
    subclass = None
    superclass = None
    def __init__(self, dtAcConv=None, tpAcConv=None, compAcConv=None, dtEfAcConv=None, dsc=None, remunSuc=None, idePeriodo=None):
        self.original_tagname_ = None
        if isinstance(dtAcConv, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dtAcConv, '%Y-%m-%d').date()
        else:
            initvalue_ = dtAcConv
        self.dtAcConv = initvalue_
        self.tpAcConv = tpAcConv
        self.compAcConv = compAcConv
        if isinstance(dtEfAcConv, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dtEfAcConv, '%Y-%m-%d').date()
        else:
            initvalue_ = dtEfAcConv
        self.dtEfAcConv = initvalue_
        self.dsc = dsc
        self.remunSuc = remunSuc
        if idePeriodo is None:
            self.idePeriodo = []
        else:
            self.idePeriodo = idePeriodo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideADC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideADC.subclass:
            return ideADC.subclass(*args_, **kwargs_)
        else:
            return ideADC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dtAcConv(self): return self.dtAcConv
    def set_dtAcConv(self, dtAcConv): self.dtAcConv = dtAcConv
    def get_tpAcConv(self): return self.tpAcConv
    def set_tpAcConv(self, tpAcConv): self.tpAcConv = tpAcConv
    def get_compAcConv(self): return self.compAcConv
    def set_compAcConv(self, compAcConv): self.compAcConv = compAcConv
    def get_dtEfAcConv(self): return self.dtEfAcConv
    def set_dtEfAcConv(self, dtEfAcConv): self.dtEfAcConv = dtEfAcConv
    def get_dsc(self): return self.dsc
    def set_dsc(self, dsc): self.dsc = dsc
    def get_remunSuc(self): return self.remunSuc
    def set_remunSuc(self, remunSuc): self.remunSuc = remunSuc
    def get_idePeriodo(self): return self.idePeriodo
    def set_idePeriodo(self, idePeriodo): self.idePeriodo = idePeriodo
    def add_idePeriodo(self, value): self.idePeriodo.append(value)
    def insert_idePeriodo_at(self, index, value): self.idePeriodo.insert(index, value)
    def replace_idePeriodo_at(self, index, value): self.idePeriodo[index] = value
    def hasContent_(self):
        if (
            self.dtAcConv is not None or
            self.tpAcConv is not None or
            self.compAcConv is not None or
            self.dtEfAcConv is not None or
            self.dsc is not None or
            self.remunSuc is not None or
            self.idePeriodo
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideADC', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideADC')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideADC')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideADC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideADC'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideADC', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dtAcConv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdtAcConv>%s</%sdtAcConv>%s' % (namespace_, self.gds_format_date(self.dtAcConv, input_name='dtAcConv'), namespace_, eol_))
        if self.tpAcConv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAcConv>%s</%stpAcConv>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpAcConv), input_name='tpAcConv')), namespace_, eol_))
        if self.compAcConv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompAcConv>%s</%scompAcConv>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.compAcConv), input_name='compAcConv')), namespace_, eol_))
        if self.dtEfAcConv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdtEfAcConv>%s</%sdtEfAcConv>%s' % (namespace_, self.gds_format_date(self.dtEfAcConv, input_name='dtEfAcConv'), namespace_, eol_))
        if self.dsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdsc>%s</%sdsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dsc), input_name='dsc')), namespace_, eol_))
        if self.remunSuc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremunSuc>%s</%sremunSuc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.remunSuc), input_name='remunSuc')), namespace_, eol_))
        for idePeriodo_ in self.idePeriodo:
            idePeriodo_.export(outfile, level, namespace_, name_='idePeriodo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dtAcConv':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dtAcConv = dval_
        elif nodeName_ == 'tpAcConv':
            tpAcConv_ = child_.text
            tpAcConv_ = self.gds_validate_string(tpAcConv_, node, 'tpAcConv')
            self.tpAcConv = tpAcConv_
        elif nodeName_ == 'compAcConv':
            compAcConv_ = child_.text
            compAcConv_ = self.gds_validate_string(compAcConv_, node, 'compAcConv')
            self.compAcConv = compAcConv_
        elif nodeName_ == 'dtEfAcConv':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dtEfAcConv = dval_
        elif nodeName_ == 'dsc':
            dsc_ = child_.text
            dsc_ = self.gds_validate_string(dsc_, node, 'dsc')
            self.dsc = dsc_
        elif nodeName_ == 'remunSuc':
            remunSuc_ = child_.text
            remunSuc_ = self.gds_validate_string(remunSuc_, node, 'remunSuc')
            self.remunSuc = remunSuc_
        elif nodeName_ == 'idePeriodo':
            obj_ = idePeriodo.factory()
            obj_.build(child_)
            self.idePeriodo.append(obj_)
            obj_.original_tagname_ = 'idePeriodo'
# end class ideADC


class dtAcConv(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dtAcConv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dtAcConv.subclass:
            return dtAcConv.subclass(*args_, **kwargs_)
        else:
            return dtAcConv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dtAcConv', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dtAcConv')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dtAcConv')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dtAcConv', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dtAcConv'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dtAcConv', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dtAcConv


class tpAcConv(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpAcConv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpAcConv.subclass:
            return tpAcConv.subclass(*args_, **kwargs_)
        else:
            return tpAcConv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpAcConv', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpAcConv')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpAcConv')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpAcConv', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpAcConv'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpAcConv', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpAcConv


class compAcConv(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, compAcConv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if compAcConv.subclass:
            return compAcConv.subclass(*args_, **kwargs_)
        else:
            return compAcConv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='compAcConv', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('compAcConv')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='compAcConv')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='compAcConv', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='compAcConv'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='compAcConv', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class compAcConv


class dtEfAcConv(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dtEfAcConv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dtEfAcConv.subclass:
            return dtEfAcConv.subclass(*args_, **kwargs_)
        else:
            return dtEfAcConv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dtEfAcConv', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dtEfAcConv')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dtEfAcConv')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dtEfAcConv', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dtEfAcConv'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dtEfAcConv', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dtEfAcConv


class dsc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dsc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dsc.subclass:
            return dsc.subclass(*args_, **kwargs_)
        else:
            return dsc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dsc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dsc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dsc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dsc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dsc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dsc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dsc


class remunSuc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remunSuc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remunSuc.subclass:
            return remunSuc.subclass(*args_, **kwargs_)
        else:
            return remunSuc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='remunSuc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remunSuc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remunSuc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='remunSuc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='remunSuc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='remunSuc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class remunSuc


class idePeriodo(GeneratedsSuper):
    """Identificação do período ao qual se referem as diferenças de
    remuneração."""
    subclass = None
    superclass = None
    def __init__(self, perRef=None, ideEstabLot=None):
        self.original_tagname_ = None
        self.perRef = perRef
        if ideEstabLot is None:
            self.ideEstabLot = []
        else:
            self.ideEstabLot = ideEstabLot
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, idePeriodo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if idePeriodo.subclass:
            return idePeriodo.subclass(*args_, **kwargs_)
        else:
            return idePeriodo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_perRef(self): return self.perRef
    def set_perRef(self, perRef): self.perRef = perRef
    def get_ideEstabLot(self): return self.ideEstabLot
    def set_ideEstabLot(self, ideEstabLot): self.ideEstabLot = ideEstabLot
    def add_ideEstabLot(self, value): self.ideEstabLot.append(value)
    def insert_ideEstabLot_at(self, index, value): self.ideEstabLot.insert(index, value)
    def replace_ideEstabLot_at(self, index, value): self.ideEstabLot[index] = value
    def hasContent_(self):
        if (
            self.perRef is not None or
            self.ideEstabLot
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='idePeriodo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('idePeriodo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='idePeriodo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='idePeriodo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='idePeriodo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='idePeriodo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.perRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sperRef>%s</%sperRef>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.perRef), input_name='perRef')), namespace_, eol_))
        for ideEstabLot_ in self.ideEstabLot:
            ideEstabLot_.export(outfile, level, namespace_, name_='ideEstabLot', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'perRef':
            perRef_ = child_.text
            perRef_ = self.gds_validate_string(perRef_, node, 'perRef')
            self.perRef = perRef_
        elif nodeName_ == 'ideEstabLot':
            obj_ = ideEstabLot.factory()
            obj_.build(child_)
            self.ideEstabLot.append(obj_)
            obj_.original_tagname_ = 'ideEstabLot'
# end class idePeriodo


class perRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, perRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if perRef.subclass:
            return perRef.subclass(*args_, **kwargs_)
        else:
            return perRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='perRef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('perRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='perRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='perRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='perRef'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='perRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class perRef


class remunPerAnt(GeneratedsSuper):
    """Informações relativas a remuneração do trabalhador em períodos
    anteriores ao período de apuração"""
    subclass = None
    superclass = None
    def __init__(self, matricula=None, indSimples=None, itensRemun=None, infoAgNocivo=None):
        self.original_tagname_ = None
        self.matricula = matricula
        self.indSimples = indSimples
        if itensRemun is None:
            self.itensRemun = []
        else:
            self.itensRemun = itensRemun
        self.infoAgNocivo = infoAgNocivo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remunPerAnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remunPerAnt.subclass:
            return remunPerAnt.subclass(*args_, **kwargs_)
        else:
            return remunPerAnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matricula(self): return self.matricula
    def set_matricula(self, matricula): self.matricula = matricula
    def get_indSimples(self): return self.indSimples
    def set_indSimples(self, indSimples): self.indSimples = indSimples
    def get_itensRemun(self): return self.itensRemun
    def set_itensRemun(self, itensRemun): self.itensRemun = itensRemun
    def add_itensRemun(self, value): self.itensRemun.append(value)
    def insert_itensRemun_at(self, index, value): self.itensRemun.insert(index, value)
    def replace_itensRemun_at(self, index, value): self.itensRemun[index] = value
    def get_infoAgNocivo(self): return self.infoAgNocivo
    def set_infoAgNocivo(self, infoAgNocivo): self.infoAgNocivo = infoAgNocivo
    def hasContent_(self):
        if (
            self.matricula is not None or
            self.indSimples is not None or
            self.itensRemun or
            self.infoAgNocivo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='remunPerAnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remunPerAnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remunPerAnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='remunPerAnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='remunPerAnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='remunPerAnt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.matricula is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smatricula>%s</%smatricula>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.matricula), input_name='matricula')), namespace_, eol_))
        if self.indSimples is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSimples>%s</%sindSimples>%s' % (namespace_, self.gds_format_integer(self.indSimples, input_name='indSimples'), namespace_, eol_))
        for itensRemun_ in self.itensRemun:
            itensRemun_.export(outfile, level, namespace_, name_='itensRemun', pretty_print=pretty_print)
        if self.infoAgNocivo is not None:
            self.infoAgNocivo.export(outfile, level, namespace_, name_='infoAgNocivo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'matricula':
            matricula_ = child_.text
            matricula_ = self.gds_validate_string(matricula_, node, 'matricula')
            self.matricula = matricula_
        elif nodeName_ == 'indSimples':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indSimples')
            self.indSimples = ival_
        elif nodeName_ == 'itensRemun':
            obj_ = TItemRemuneracao.factory()
            obj_.build(child_)
            self.itensRemun.append(obj_)
            obj_.original_tagname_ = 'itensRemun'
        elif nodeName_ == 'infoAgNocivo':
            obj_ = infoAgNocivo.factory()
            obj_.build(child_)
            self.infoAgNocivo = obj_
            obj_.original_tagname_ = 'infoAgNocivo'
# end class remunPerAnt


class infoTrabInterm(GeneratedsSuper):
    """Informações da(s) convocação(ões) de trabalho intermitente"""
    subclass = None
    superclass = None
    def __init__(self, codConv=None):
        self.original_tagname_ = None
        self.codConv = codConv
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoTrabInterm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoTrabInterm.subclass:
            return infoTrabInterm.subclass(*args_, **kwargs_)
        else:
            return infoTrabInterm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codConv(self): return self.codConv
    def set_codConv(self, codConv): self.codConv = codConv
    def hasContent_(self):
        if (
            self.codConv is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoTrabInterm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoTrabInterm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoTrabInterm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoTrabInterm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoTrabInterm'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoTrabInterm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codConv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodConv>%s</%scodConv>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codConv), input_name='codConv')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codConv':
            codConv_ = child_.text
            codConv_ = self.gds_validate_string(codConv_, node, 'codConv')
            self.codConv = codConv_
# end class infoTrabInterm


class codConv(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codConv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codConv.subclass:
            return codConv.subclass(*args_, **kwargs_)
        else:
            return codConv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codConv', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codConv')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codConv')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codConv', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codConv'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codConv', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codConv


class TEmpregador(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEmpregador)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEmpregador.subclass:
            return TEmpregador.subclass(*args_, **kwargs_)
        else:
            return TEmpregador(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEmpregador', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEmpregador')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEmpregador')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEmpregador', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEmpregador'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEmpregador', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
# end class TEmpregador


class TRemunOutrasEmpresas(GeneratedsSuper):
    """Registro que complementa as informações relativas ao trabalhador que
    possui vínculo empregatício com outra(s) empresa(s) e/ou que
    exerce outras atividades como contribuinte individual,
    detalhando as empresas que efetuaram (ou efetuarão) desconto da
    contribuição, ou ainda valores recolhidos pelo próprio
    trabalhador como contribuinte individual. As informações
    prestadas são necessárias para a conferência da contribuição
    descontada do segurado."""
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None, codCateg=None, vlrRemunOE=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
        self.codCateg = codCateg
        self.vlrRemunOE = vlrRemunOE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRemunOutrasEmpresas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRemunOutrasEmpresas.subclass:
            return TRemunOutrasEmpresas.subclass(*args_, **kwargs_)
        else:
            return TRemunOutrasEmpresas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def get_codCateg(self): return self.codCateg
    def set_codCateg(self, codCateg): self.codCateg = codCateg
    def get_vlrRemunOE(self): return self.vlrRemunOE
    def set_vlrRemunOE(self, vlrRemunOE): self.vlrRemunOE = vlrRemunOE
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None or
            self.codCateg is not None or
            self.vlrRemunOE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TRemunOutrasEmpresas', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRemunOutrasEmpresas')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TRemunOutrasEmpresas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TRemunOutrasEmpresas', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TRemunOutrasEmpresas'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TRemunOutrasEmpresas', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
        if self.codCateg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodCateg>%s</%scodCateg>%s' % (namespace_, self.gds_format_integer(self.codCateg, input_name='codCateg'), namespace_, eol_))
        if self.vlrRemunOE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svlrRemunOE>%s</%svlrRemunOE>%s' % (namespace_, self.gds_format_float(self.vlrRemunOE, input_name='vlrRemunOE'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
        elif nodeName_ == 'codCateg':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codCateg')
            self.codCateg = ival_
        elif nodeName_ == 'vlrRemunOE':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vlrRemunOE')
            self.vlrRemunOE = fval_
# end class TRemunOutrasEmpresas


class vlrRemunOE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vlrRemunOE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vlrRemunOE.subclass:
            return vlrRemunOE.subclass(*args_, **kwargs_)
        else:
            return vlrRemunOE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vlrRemunOE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vlrRemunOE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vlrRemunOE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vlrRemunOE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vlrRemunOE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vlrRemunOE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vlrRemunOE


class TItemRemuneracao(GeneratedsSuper):
    """Informações dos Itens (rubricas) da remuneração"""
    subclass = None
    superclass = None
    def __init__(self, codRubr=None, ideTabRubr=None, qtdRubr=None, fatorRubr=None, vrUnit=None, vrRubr=None):
        self.original_tagname_ = None
        self.codRubr = codRubr
        self.ideTabRubr = ideTabRubr
        self.qtdRubr = qtdRubr
        self.fatorRubr = fatorRubr
        self.vrUnit = vrUnit
        self.vrRubr = vrRubr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TItemRemuneracao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TItemRemuneracao.subclass:
            return TItemRemuneracao.subclass(*args_, **kwargs_)
        else:
            return TItemRemuneracao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codRubr(self): return self.codRubr
    def set_codRubr(self, codRubr): self.codRubr = codRubr
    def get_ideTabRubr(self): return self.ideTabRubr
    def set_ideTabRubr(self, ideTabRubr): self.ideTabRubr = ideTabRubr
    def get_qtdRubr(self): return self.qtdRubr
    def set_qtdRubr(self, qtdRubr): self.qtdRubr = qtdRubr
    def get_fatorRubr(self): return self.fatorRubr
    def set_fatorRubr(self, fatorRubr): self.fatorRubr = fatorRubr
    def get_vrUnit(self): return self.vrUnit
    def set_vrUnit(self, vrUnit): self.vrUnit = vrUnit
    def get_vrRubr(self): return self.vrRubr
    def set_vrRubr(self, vrRubr): self.vrRubr = vrRubr
    def hasContent_(self):
        if (
            self.codRubr is not None or
            self.ideTabRubr is not None or
            self.qtdRubr is not None or
            self.fatorRubr is not None or
            self.vrUnit is not None or
            self.vrRubr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TItemRemuneracao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TItemRemuneracao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TItemRemuneracao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TItemRemuneracao', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TItemRemuneracao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TItemRemuneracao', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodRubr>%s</%scodRubr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.codRubr), input_name='codRubr')), namespace_, eol_))
        if self.ideTabRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sideTabRubr>%s</%sideTabRubr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ideTabRubr), input_name='ideTabRubr')), namespace_, eol_))
        if self.qtdRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtdRubr>%s</%sqtdRubr>%s' % (namespace_, self.gds_format_float(self.qtdRubr, input_name='qtdRubr'), namespace_, eol_))
        if self.fatorRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfatorRubr>%s</%sfatorRubr>%s' % (namespace_, self.gds_format_float(self.fatorRubr, input_name='fatorRubr'), namespace_, eol_))
        if self.vrUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrUnit>%s</%svrUnit>%s' % (namespace_, self.gds_format_float(self.vrUnit, input_name='vrUnit'), namespace_, eol_))
        if self.vrRubr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrRubr>%s</%svrRubr>%s' % (namespace_, self.gds_format_float(self.vrRubr, input_name='vrRubr'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codRubr':
            codRubr_ = child_.text
            codRubr_ = self.gds_validate_string(codRubr_, node, 'codRubr')
            self.codRubr = codRubr_
        elif nodeName_ == 'ideTabRubr':
            ideTabRubr_ = child_.text
            ideTabRubr_ = self.gds_validate_string(ideTabRubr_, node, 'ideTabRubr')
            self.ideTabRubr = ideTabRubr_
        elif nodeName_ == 'qtdRubr':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'qtdRubr')
            self.qtdRubr = fval_
        elif nodeName_ == 'fatorRubr':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fatorRubr')
            self.fatorRubr = fval_
        elif nodeName_ == 'vrUnit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrUnit')
            self.vrUnit = fval_
        elif nodeName_ == 'vrRubr':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRubr')
            self.vrRubr = fval_
# end class TItemRemuneracao


class codRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codRubr.subclass:
            return codRubr.subclass(*args_, **kwargs_)
        else:
            return codRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codRubr


class ideTabRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideTabRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideTabRubr.subclass:
            return ideTabRubr.subclass(*args_, **kwargs_)
        else:
            return ideTabRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideTabRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideTabRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideTabRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideTabRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideTabRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideTabRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ideTabRubr


class qtdRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qtdRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qtdRubr.subclass:
            return qtdRubr.subclass(*args_, **kwargs_)
        else:
            return qtdRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qtdRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qtdRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qtdRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qtdRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qtdRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qtdRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qtdRubr


class fatorRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fatorRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fatorRubr.subclass:
            return fatorRubr.subclass(*args_, **kwargs_)
        else:
            return fatorRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fatorRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fatorRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fatorRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fatorRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fatorRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fatorRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fatorRubr


class vrUnit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrUnit.subclass:
            return vrUnit.subclass(*args_, **kwargs_)
        else:
            return vrUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrUnit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrUnit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrUnit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrUnit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrUnit


class vrRubr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrRubr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrRubr.subclass:
            return vrRubr.subclass(*args_, **kwargs_)
        else:
            return vrRubr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrRubr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrRubr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrRubr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrRubr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrRubr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrRubr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrRubr


class TSaudeCol(GeneratedsSuper):
    """Planos de saúde coletivo"""
    subclass = None
    superclass = None
    def __init__(self, detOper=None):
        self.original_tagname_ = None
        if detOper is None:
            self.detOper = []
        else:
            self.detOper = detOper
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TSaudeCol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TSaudeCol.subclass:
            return TSaudeCol.subclass(*args_, **kwargs_)
        else:
            return TSaudeCol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_detOper(self): return self.detOper
    def set_detOper(self, detOper): self.detOper = detOper
    def add_detOper(self, value): self.detOper.append(value)
    def insert_detOper_at(self, index, value): self.detOper.insert(index, value)
    def replace_detOper_at(self, index, value): self.detOper[index] = value
    def hasContent_(self):
        if (
            self.detOper
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TSaudeCol', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TSaudeCol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TSaudeCol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TSaudeCol', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TSaudeCol'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TSaudeCol', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for detOper_ in self.detOper:
            detOper_.export(outfile, level, namespace_, name_='detOper', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'detOper':
            obj_ = detOper.factory()
            obj_.build(child_)
            self.detOper.append(obj_)
            obj_.original_tagname_ = 'detOper'
# end class TSaudeCol


class detOper(GeneratedsSuper):
    """Detalhamento dos valores pagos a Operadoras de Planos de Saúde."""
    subclass = None
    superclass = None
    def __init__(self, cnpjOper=None, regANS=None, vrPgTit=None, detPlano=None):
        self.original_tagname_ = None
        self.cnpjOper = cnpjOper
        self.regANS = regANS
        self.vrPgTit = vrPgTit
        if detPlano is None:
            self.detPlano = []
        else:
            self.detPlano = detPlano
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detOper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detOper.subclass:
            return detOper.subclass(*args_, **kwargs_)
        else:
            return detOper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnpjOper(self): return self.cnpjOper
    def set_cnpjOper(self, cnpjOper): self.cnpjOper = cnpjOper
    def get_regANS(self): return self.regANS
    def set_regANS(self, regANS): self.regANS = regANS
    def get_vrPgTit(self): return self.vrPgTit
    def set_vrPgTit(self, vrPgTit): self.vrPgTit = vrPgTit
    def get_detPlano(self): return self.detPlano
    def set_detPlano(self, detPlano): self.detPlano = detPlano
    def add_detPlano(self, value): self.detPlano.append(value)
    def insert_detPlano_at(self, index, value): self.detPlano.insert(index, value)
    def replace_detPlano_at(self, index, value): self.detPlano[index] = value
    def hasContent_(self):
        if (
            self.cnpjOper is not None or
            self.regANS is not None or
            self.vrPgTit is not None or
            self.detPlano
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detOper', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detOper')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detOper')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detOper', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detOper'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='detOper', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnpjOper is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scnpjOper>%s</%scnpjOper>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cnpjOper), input_name='cnpjOper')), namespace_, eol_))
        if self.regANS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregANS>%s</%sregANS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.regANS), input_name='regANS')), namespace_, eol_))
        if self.vrPgTit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrPgTit>%s</%svrPgTit>%s' % (namespace_, self.gds_format_float(self.vrPgTit, input_name='vrPgTit'), namespace_, eol_))
        for detPlano_ in self.detPlano:
            detPlano_.export(outfile, level, namespace_, name_='detPlano', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnpjOper':
            cnpjOper_ = child_.text
            cnpjOper_ = self.gds_validate_string(cnpjOper_, node, 'cnpjOper')
            self.cnpjOper = cnpjOper_
        elif nodeName_ == 'regANS':
            regANS_ = child_.text
            regANS_ = self.gds_validate_string(regANS_, node, 'regANS')
            self.regANS = regANS_
        elif nodeName_ == 'vrPgTit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrPgTit')
            self.vrPgTit = fval_
        elif nodeName_ == 'detPlano':
            obj_ = detPlano.factory()
            obj_.build(child_)
            self.detPlano.append(obj_)
            obj_.original_tagname_ = 'detPlano'
# end class detOper


class cnpjOper(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cnpjOper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cnpjOper.subclass:
            return cnpjOper.subclass(*args_, **kwargs_)
        else:
            return cnpjOper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cnpjOper', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cnpjOper')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cnpjOper')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cnpjOper', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cnpjOper'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cnpjOper', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cnpjOper


class regANS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, regANS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if regANS.subclass:
            return regANS.subclass(*args_, **kwargs_)
        else:
            return regANS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='regANS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('regANS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='regANS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='regANS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='regANS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='regANS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class regANS


class vrPgTit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vrPgTit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vrPgTit.subclass:
            return vrPgTit.subclass(*args_, **kwargs_)
        else:
            return vrPgTit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vrPgTit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vrPgTit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vrPgTit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vrPgTit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vrPgTit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vrPgTit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vrPgTit


class detPlano(GeneratedsSuper):
    """Informações do dependente do plano privado de saúde."""
    subclass = None
    superclass = None
    def __init__(self, tpDep=None, cpfDep=None, nmDep=None, dtNascto=None, vlrPgDep=None):
        self.original_tagname_ = None
        self.tpDep = tpDep
        self.cpfDep = cpfDep
        self.nmDep = nmDep
        if isinstance(dtNascto, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dtNascto, '%Y-%m-%d').date()
        else:
            initvalue_ = dtNascto
        self.dtNascto = initvalue_
        self.vlrPgDep = vlrPgDep
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detPlano)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detPlano.subclass:
            return detPlano.subclass(*args_, **kwargs_)
        else:
            return detPlano(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpDep(self): return self.tpDep
    def set_tpDep(self, tpDep): self.tpDep = tpDep
    def get_cpfDep(self): return self.cpfDep
    def set_cpfDep(self, cpfDep): self.cpfDep = cpfDep
    def get_nmDep(self): return self.nmDep
    def set_nmDep(self, nmDep): self.nmDep = nmDep
    def get_dtNascto(self): return self.dtNascto
    def set_dtNascto(self, dtNascto): self.dtNascto = dtNascto
    def get_vlrPgDep(self): return self.vlrPgDep
    def set_vlrPgDep(self, vlrPgDep): self.vlrPgDep = vlrPgDep
    def hasContent_(self):
        if (
            self.tpDep is not None or
            self.cpfDep is not None or
            self.nmDep is not None or
            self.dtNascto is not None or
            self.vlrPgDep is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detPlano', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detPlano')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detPlano')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detPlano', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detPlano'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='detPlano', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpDep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpDep>%s</%stpDep>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpDep), input_name='tpDep')), namespace_, eol_))
        if self.cpfDep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpfDep>%s</%scpfDep>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cpfDep), input_name='cpfDep')), namespace_, eol_))
        if self.nmDep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snmDep>%s</%snmDep>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nmDep), input_name='nmDep')), namespace_, eol_))
        if self.dtNascto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdtNascto>%s</%sdtNascto>%s' % (namespace_, self.gds_format_date(self.dtNascto, input_name='dtNascto'), namespace_, eol_))
        if self.vlrPgDep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svlrPgDep>%s</%svlrPgDep>%s' % (namespace_, self.gds_format_float(self.vlrPgDep, input_name='vlrPgDep'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpDep':
            tpDep_ = child_.text
            tpDep_ = self.gds_validate_string(tpDep_, node, 'tpDep')
            self.tpDep = tpDep_
        elif nodeName_ == 'cpfDep':
            cpfDep_ = child_.text
            cpfDep_ = self.gds_validate_string(cpfDep_, node, 'cpfDep')
            self.cpfDep = cpfDep_
        elif nodeName_ == 'nmDep':
            nmDep_ = child_.text
            nmDep_ = self.gds_validate_string(nmDep_, node, 'nmDep')
            self.nmDep = nmDep_
        elif nodeName_ == 'dtNascto':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dtNascto = dval_
        elif nodeName_ == 'vlrPgDep':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vlrPgDep')
            self.vlrPgDep = fval_
# end class detPlano


class tpDep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpDep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpDep.subclass:
            return tpDep.subclass(*args_, **kwargs_)
        else:
            return tpDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpDep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpDep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpDep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpDep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpDep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpDep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpDep


class cpfDep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cpfDep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cpfDep.subclass:
            return cpfDep.subclass(*args_, **kwargs_)
        else:
            return cpfDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cpfDep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpfDep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cpfDep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cpfDep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cpfDep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cpfDep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cpfDep


class nmDep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nmDep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nmDep.subclass:
            return nmDep.subclass(*args_, **kwargs_)
        else:
            return nmDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nmDep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nmDep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nmDep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nmDep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nmDep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nmDep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nmDep


class vlrPgDep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vlrPgDep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vlrPgDep.subclass:
            return vlrPgDep.subclass(*args_, **kwargs_)
        else:
            return vlrPgDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vlrPgDep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vlrPgDep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vlrPgDep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vlrPgDep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vlrPgDep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vlrPgDep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vlrPgDep


GDSClassesMapping = {
    'ideEmpregador': TEmpregador,
    'infoSaudeColet': TSaudeCol,
    'itensRemun': TItemRemuneracao,
    'remunOutrEmpr': TRemunOutrasEmpresas,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from evtRemun import *\n\n')
        sys.stdout.write('import evtRemun as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "TEmpregador",
    "TItemRemuneracao",
    "TRemunOutrasEmpresas",
    "TSaudeCol",
    "eSocial"
]
