#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Oct 10 00:42:26 2017 by generateDS.py version 2.28b.
# Python 2.7.12 (default, Nov 19 2016, 06:48:10)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('--no-process-includes', '')
#   ('-o', 'esociallib/v2_04/evtTabEstab.py')
#
# Command line arguments:
#   schemas/v2_04/evtTabEstab.xsd
#
# Command line:
#   /usr/local/bin/generateDS --no-process-includes -o "esociallib/v2_04/evtTabEstab.py" schemas/v2_04/evtTabEstab.xsd
#
# Current working directory (os.getcwd()):
#   esociallib
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class eSocial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evtTabEstab=None, Signature=None):
        self.original_tagname_ = None
        self.evtTabEstab = evtTabEstab
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eSocial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eSocial.subclass:
            return eSocial.subclass(*args_, **kwargs_)
        else:
            return eSocial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evtTabEstab(self): return self.evtTabEstab
    def set_evtTabEstab(self, evtTabEstab): self.evtTabEstab = evtTabEstab
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def hasContent_(self):
        if (
            self.evtTabEstab is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eSocial', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eSocial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eSocial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eSocial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eSocial'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='eSocial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.evtTabEstab is not None:
            self.evtTabEstab.export(outfile, level, namespace_, name_='evtTabEstab', pretty_print=pretty_print)
        if self.Signature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSignature>%s</%sSignature>%s' % ('ds:', self.gds_encode(self.gds_format_string(quote_xml(self.Signature), input_name='Signature')), 'ds:', eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'evtTabEstab':
            obj_ = evtTabEstab.factory()
            obj_.build(child_)
            self.evtTabEstab = obj_
            obj_.original_tagname_ = 'evtTabEstab'
        elif nodeName_ == 'Signature':
            Signature_ = child_.text
            Signature_ = self.gds_validate_string(Signature_, node, 'Signature')
            self.Signature = Signature_
# end class eSocial


class evtTabEstab(GeneratedsSuper):
    """Evento tabela de estabelecimentos, obras de construção civil ou
    Órgãos Públicos"""
    subclass = None
    superclass = None
    def __init__(self, Id=None, ideEvento=None, ideEmpregador=None, infoEstab=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.ideEvento = ideEvento
        self.ideEmpregador = ideEmpregador
        self.infoEstab = infoEstab
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, evtTabEstab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if evtTabEstab.subclass:
            return evtTabEstab.subclass(*args_, **kwargs_)
        else:
            return evtTabEstab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideEvento(self): return self.ideEvento
    def set_ideEvento(self, ideEvento): self.ideEvento = ideEvento
    def get_ideEmpregador(self): return self.ideEmpregador
    def set_ideEmpregador(self, ideEmpregador): self.ideEmpregador = ideEmpregador
    def get_infoEstab(self): return self.infoEstab
    def set_infoEstab(self, infoEstab): self.infoEstab = infoEstab
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.ideEvento is not None or
            self.ideEmpregador is not None or
            self.infoEstab is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='evtTabEstab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('evtTabEstab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='evtTabEstab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='evtTabEstab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='evtTabEstab'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='evtTabEstab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideEvento is not None:
            self.ideEvento.export(outfile, level, namespace_, name_='ideEvento', pretty_print=pretty_print)
        if self.ideEmpregador is not None:
            self.ideEmpregador.export(outfile, level, namespace_, name_='ideEmpregador', pretty_print=pretty_print)
        if self.infoEstab is not None:
            self.infoEstab.export(outfile, level, namespace_, name_='infoEstab', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideEvento':
            obj_ = TIdeCadastro.factory()
            obj_.build(child_)
            self.ideEvento = obj_
            obj_.original_tagname_ = 'ideEvento'
        elif nodeName_ == 'ideEmpregador':
            obj_ = TEmpregador.factory()
            obj_.build(child_)
            self.ideEmpregador = obj_
            obj_.original_tagname_ = 'ideEmpregador'
        elif nodeName_ == 'infoEstab':
            obj_ = infoEstab.factory()
            obj_.build(child_)
            self.infoEstab = obj_
            obj_.original_tagname_ = 'infoEstab'
# end class evtTabEstab


class infoEstab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, inclusao=None, alteracao=None, exclusao=None):
        self.original_tagname_ = None
        self.inclusao = inclusao
        self.alteracao = alteracao
        self.exclusao = exclusao
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoEstab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoEstab.subclass:
            return infoEstab.subclass(*args_, **kwargs_)
        else:
            return infoEstab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inclusao(self): return self.inclusao
    def set_inclusao(self, inclusao): self.inclusao = inclusao
    def get_alteracao(self): return self.alteracao
    def set_alteracao(self, alteracao): self.alteracao = alteracao
    def get_exclusao(self): return self.exclusao
    def set_exclusao(self, exclusao): self.exclusao = exclusao
    def hasContent_(self):
        if (
            self.inclusao is not None or
            self.alteracao is not None or
            self.exclusao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoEstab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoEstab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoEstab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoEstab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoEstab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoEstab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inclusao is not None:
            self.inclusao.export(outfile, level, namespace_, name_='inclusao', pretty_print=pretty_print)
        if self.alteracao is not None:
            self.alteracao.export(outfile, level, namespace_, name_='alteracao', pretty_print=pretty_print)
        if self.exclusao is not None:
            self.exclusao.export(outfile, level, namespace_, name_='exclusao', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inclusao':
            obj_ = inclusao.factory()
            obj_.build(child_)
            self.inclusao = obj_
            obj_.original_tagname_ = 'inclusao'
        elif nodeName_ == 'alteracao':
            obj_ = alteracao.factory()
            obj_.build(child_)
            self.alteracao = obj_
            obj_.original_tagname_ = 'alteracao'
        elif nodeName_ == 'exclusao':
            obj_ = exclusao.factory()
            obj_.build(child_)
            self.exclusao = obj_
            obj_.original_tagname_ = 'exclusao'
# end class infoEstab


class inclusao(GeneratedsSuper):
    """Inclusão de novas informações"""
    subclass = None
    superclass = None
    def __init__(self, ideEstab=None, dadosEstab=None):
        self.original_tagname_ = None
        self.ideEstab = ideEstab
        self.dadosEstab = dadosEstab
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, inclusao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if inclusao.subclass:
            return inclusao.subclass(*args_, **kwargs_)
        else:
            return inclusao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideEstab(self): return self.ideEstab
    def set_ideEstab(self, ideEstab): self.ideEstab = ideEstab
    def get_dadosEstab(self): return self.dadosEstab
    def set_dadosEstab(self, dadosEstab): self.dadosEstab = dadosEstab
    def hasContent_(self):
        if (
            self.ideEstab is not None or
            self.dadosEstab is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='inclusao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('inclusao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='inclusao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='inclusao', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='inclusao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='inclusao', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideEstab is not None:
            self.ideEstab.export(outfile, level, namespace_, name_='ideEstab', pretty_print=pretty_print)
        if self.dadosEstab is not None:
            self.dadosEstab.export(outfile, level, namespace_, name_='dadosEstab', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideEstab':
            obj_ = TIdeEstab.factory()
            obj_.build(child_)
            self.ideEstab = obj_
            obj_.original_tagname_ = 'ideEstab'
        elif nodeName_ == 'dadosEstab':
            obj_ = TDadosEstab.factory()
            obj_.build(child_)
            self.dadosEstab = obj_
            obj_.original_tagname_ = 'dadosEstab'
# end class inclusao


class alteracao(GeneratedsSuper):
    """Alteração de informações já existentes"""
    subclass = None
    superclass = None
    def __init__(self, ideEstab=None, dadosEstab=None, novaValidade=None):
        self.original_tagname_ = None
        self.ideEstab = ideEstab
        self.dadosEstab = dadosEstab
        self.novaValidade = novaValidade
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alteracao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alteracao.subclass:
            return alteracao.subclass(*args_, **kwargs_)
        else:
            return alteracao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideEstab(self): return self.ideEstab
    def set_ideEstab(self, ideEstab): self.ideEstab = ideEstab
    def get_dadosEstab(self): return self.dadosEstab
    def set_dadosEstab(self, dadosEstab): self.dadosEstab = dadosEstab
    def get_novaValidade(self): return self.novaValidade
    def set_novaValidade(self, novaValidade): self.novaValidade = novaValidade
    def hasContent_(self):
        if (
            self.ideEstab is not None or
            self.dadosEstab is not None or
            self.novaValidade is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alteracao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alteracao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alteracao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alteracao', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alteracao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='alteracao', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideEstab is not None:
            self.ideEstab.export(outfile, level, namespace_, name_='ideEstab', pretty_print=pretty_print)
        if self.dadosEstab is not None:
            self.dadosEstab.export(outfile, level, namespace_, name_='dadosEstab', pretty_print=pretty_print)
        if self.novaValidade is not None:
            self.novaValidade.export(outfile, level, namespace_, name_='novaValidade', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideEstab':
            obj_ = TIdeEstab.factory()
            obj_.build(child_)
            self.ideEstab = obj_
            obj_.original_tagname_ = 'ideEstab'
        elif nodeName_ == 'dadosEstab':
            obj_ = TDadosEstab.factory()
            obj_.build(child_)
            self.dadosEstab = obj_
            obj_.original_tagname_ = 'dadosEstab'
        elif nodeName_ == 'novaValidade':
            obj_ = TPeriodoValidade.factory()
            obj_.build(child_)
            self.novaValidade = obj_
            obj_.original_tagname_ = 'novaValidade'
# end class alteracao


class exclusao(GeneratedsSuper):
    """Exclusão de informações"""
    subclass = None
    superclass = None
    def __init__(self, ideEstab=None):
        self.original_tagname_ = None
        self.ideEstab = ideEstab
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exclusao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exclusao.subclass:
            return exclusao.subclass(*args_, **kwargs_)
        else:
            return exclusao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideEstab(self): return self.ideEstab
    def set_ideEstab(self, ideEstab): self.ideEstab = ideEstab
    def hasContent_(self):
        if (
            self.ideEstab is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exclusao', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exclusao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exclusao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exclusao', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exclusao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='exclusao', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideEstab is not None:
            self.ideEstab.export(outfile, level, namespace_, name_='ideEstab', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideEstab':
            obj_ = TIdeEstab.factory()
            obj_.build(child_)
            self.ideEstab = obj_
            obj_.original_tagname_ = 'ideEstab'
# end class exclusao


class TIdeCadastro(GeneratedsSuper):
    """Identificação de evento de cadastro/tabelas"""
    subclass = None
    superclass = None
    def __init__(self, tpAmb=None, procEmi=None, verProc=None):
        self.original_tagname_ = None
        self.tpAmb = tpAmb
        self.procEmi = procEmi
        self.verProc = verProc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TIdeCadastro)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TIdeCadastro.subclass:
            return TIdeCadastro.subclass(*args_, **kwargs_)
        else:
            return TIdeCadastro(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_procEmi(self): return self.procEmi
    def set_procEmi(self, procEmi): self.procEmi = procEmi
    def get_verProc(self): return self.verProc
    def set_verProc(self, verProc): self.verProc = verProc
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.procEmi is not None or
            self.verProc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TIdeCadastro', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TIdeCadastro')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TIdeCadastro')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TIdeCadastro', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TIdeCadastro'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TIdeCadastro', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespace_, self.gds_format_integer(self.tpAmb, input_name='tpAmb'), namespace_, eol_))
        if self.procEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocEmi>%s</%sprocEmi>%s' % (namespace_, self.gds_format_integer(self.procEmi, input_name='procEmi'), namespace_, eol_))
        if self.verProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverProc>%s</%sverProc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.verProc), input_name='verProc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpAmb')
            self.tpAmb = ival_
        elif nodeName_ == 'procEmi':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'procEmi')
            self.procEmi = ival_
        elif nodeName_ == 'verProc':
            verProc_ = child_.text
            verProc_ = self.gds_validate_string(verProc_, node, 'verProc')
            self.verProc = verProc_
# end class TIdeCadastro


class tpAmb(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpAmb)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpAmb.subclass:
            return tpAmb.subclass(*args_, **kwargs_)
        else:
            return tpAmb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpAmb', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpAmb')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpAmb')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpAmb', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpAmb'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpAmb', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpAmb


class procEmi(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procEmi.subclass:
            return procEmi.subclass(*args_, **kwargs_)
        else:
            return procEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='procEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='procEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='procEmi', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='procEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procEmi', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class procEmi


class verProc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, verProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if verProc.subclass:
            return verProc.subclass(*args_, **kwargs_)
        else:
            return verProc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='verProc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('verProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='verProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='verProc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='verProc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='verProc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class verProc


class TEmpregador(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEmpregador)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEmpregador.subclass:
            return TEmpregador.subclass(*args_, **kwargs_)
        else:
            return TEmpregador(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEmpregador', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEmpregador')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEmpregador')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEmpregador', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEmpregador'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEmpregador', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
# end class TEmpregador


class tpInsc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpInsc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpInsc.subclass:
            return tpInsc.subclass(*args_, **kwargs_)
        else:
            return tpInsc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpInsc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpInsc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpInsc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpInsc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpInsc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpInsc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpInsc


class nrInsc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrInsc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrInsc.subclass:
            return nrInsc.subclass(*args_, **kwargs_)
        else:
            return nrInsc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrInsc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrInsc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrInsc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrInsc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrInsc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrInsc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrInsc


class TIdeEstab(GeneratedsSuper):
    """Identificação do estabelecimento, obra ou órgão público e validade
    das informações"""
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None, iniValid=None, fimValid=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.nrInsc = nrInsc
        self.iniValid = iniValid
        self.fimValid = fimValid
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TIdeEstab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TIdeEstab.subclass:
            return TIdeEstab.subclass(*args_, **kwargs_)
        else:
            return TIdeEstab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def get_iniValid(self): return self.iniValid
    def set_iniValid(self, iniValid): self.iniValid = iniValid
    def get_fimValid(self): return self.fimValid
    def set_fimValid(self, fimValid): self.fimValid = fimValid
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None or
            self.iniValid is not None or
            self.fimValid is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TIdeEstab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TIdeEstab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TIdeEstab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TIdeEstab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TIdeEstab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TIdeEstab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpInsc>%s</%stpInsc>%s' % (namespace_, self.gds_format_integer(self.tpInsc, input_name='tpInsc'), namespace_, eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
        if self.iniValid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siniValid>%s</%siniValid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.iniValid), input_name='iniValid')), namespace_, eol_))
        if self.fimValid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfimValid>%s</%sfimValid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fimValid), input_name='fimValid')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpInsc')
            self.tpInsc = ival_
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
        elif nodeName_ == 'iniValid':
            iniValid_ = child_.text
            iniValid_ = self.gds_validate_string(iniValid_, node, 'iniValid')
            self.iniValid = iniValid_
        elif nodeName_ == 'fimValid':
            fimValid_ = child_.text
            fimValid_ = self.gds_validate_string(fimValid_, node, 'fimValid')
            self.fimValid = fimValid_
# end class TIdeEstab


class iniValid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iniValid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iniValid.subclass:
            return iniValid.subclass(*args_, **kwargs_)
        else:
            return iniValid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='iniValid', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('iniValid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iniValid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='iniValid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='iniValid'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='iniValid', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class iniValid


class fimValid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fimValid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fimValid.subclass:
            return fimValid.subclass(*args_, **kwargs_)
        else:
            return fimValid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fimValid', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fimValid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fimValid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fimValid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fimValid'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fimValid', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fimValid


class TDadosEstab(GeneratedsSuper):
    """Detalhamento das informações do estabelecimento/obra"""
    subclass = None
    superclass = None
    def __init__(self, cnaePrep=None, aliqGilrat=None, infoCaepf=None, infoObra=None, infoTrab=None):
        self.original_tagname_ = None
        self.cnaePrep = cnaePrep
        self.aliqGilrat = aliqGilrat
        self.infoCaepf = infoCaepf
        self.infoObra = infoObra
        self.infoTrab = infoTrab
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TDadosEstab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TDadosEstab.subclass:
            return TDadosEstab.subclass(*args_, **kwargs_)
        else:
            return TDadosEstab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnaePrep(self): return self.cnaePrep
    def set_cnaePrep(self, cnaePrep): self.cnaePrep = cnaePrep
    def get_aliqGilrat(self): return self.aliqGilrat
    def set_aliqGilrat(self, aliqGilrat): self.aliqGilrat = aliqGilrat
    def get_infoCaepf(self): return self.infoCaepf
    def set_infoCaepf(self, infoCaepf): self.infoCaepf = infoCaepf
    def get_infoObra(self): return self.infoObra
    def set_infoObra(self, infoObra): self.infoObra = infoObra
    def get_infoTrab(self): return self.infoTrab
    def set_infoTrab(self, infoTrab): self.infoTrab = infoTrab
    def hasContent_(self):
        if (
            self.cnaePrep is not None or
            self.aliqGilrat is not None or
            self.infoCaepf is not None or
            self.infoObra is not None or
            self.infoTrab is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TDadosEstab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TDadosEstab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TDadosEstab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TDadosEstab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TDadosEstab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TDadosEstab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnaePrep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scnaePrep>%s</%scnaePrep>%s' % (namespace_, self.gds_format_integer(self.cnaePrep, input_name='cnaePrep'), namespace_, eol_))
        if self.aliqGilrat is not None:
            self.aliqGilrat.export(outfile, level, namespace_, name_='aliqGilrat', pretty_print=pretty_print)
        if self.infoCaepf is not None:
            self.infoCaepf.export(outfile, level, namespace_, name_='infoCaepf', pretty_print=pretty_print)
        if self.infoObra is not None:
            self.infoObra.export(outfile, level, namespace_, name_='infoObra', pretty_print=pretty_print)
        if self.infoTrab is not None:
            self.infoTrab.export(outfile, level, namespace_, name_='infoTrab', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnaePrep':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cnaePrep')
            self.cnaePrep = ival_
        elif nodeName_ == 'aliqGilrat':
            obj_ = aliqGilrat.factory()
            obj_.build(child_)
            self.aliqGilrat = obj_
            obj_.original_tagname_ = 'aliqGilrat'
        elif nodeName_ == 'infoCaepf':
            obj_ = infoCaepf.factory()
            obj_.build(child_)
            self.infoCaepf = obj_
            obj_.original_tagname_ = 'infoCaepf'
        elif nodeName_ == 'infoObra':
            obj_ = infoObra.factory()
            obj_.build(child_)
            self.infoObra = obj_
            obj_.original_tagname_ = 'infoObra'
        elif nodeName_ == 'infoTrab':
            obj_ = infoTrab.factory()
            obj_.build(child_)
            self.infoTrab = obj_
            obj_.original_tagname_ = 'infoTrab'
# end class TDadosEstab


class cnaePrep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cnaePrep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cnaePrep.subclass:
            return cnaePrep.subclass(*args_, **kwargs_)
        else:
            return cnaePrep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cnaePrep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cnaePrep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cnaePrep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cnaePrep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cnaePrep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cnaePrep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cnaePrep


class aliqGilrat(GeneratedsSuper):
    """Informações de Apuração da alíquota Gilrat do Estabelecimento"""
    subclass = None
    superclass = None
    def __init__(self, aliqRat=None, fap=None, aliqRatAjust=None, procAdmJudRat=None, procAdmJudFap=None):
        self.original_tagname_ = None
        self.aliqRat = aliqRat
        self.fap = fap
        self.aliqRatAjust = aliqRatAjust
        self.procAdmJudRat = procAdmJudRat
        self.procAdmJudFap = procAdmJudFap
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, aliqGilrat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if aliqGilrat.subclass:
            return aliqGilrat.subclass(*args_, **kwargs_)
        else:
            return aliqGilrat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aliqRat(self): return self.aliqRat
    def set_aliqRat(self, aliqRat): self.aliqRat = aliqRat
    def get_fap(self): return self.fap
    def set_fap(self, fap): self.fap = fap
    def get_aliqRatAjust(self): return self.aliqRatAjust
    def set_aliqRatAjust(self, aliqRatAjust): self.aliqRatAjust = aliqRatAjust
    def get_procAdmJudRat(self): return self.procAdmJudRat
    def set_procAdmJudRat(self, procAdmJudRat): self.procAdmJudRat = procAdmJudRat
    def get_procAdmJudFap(self): return self.procAdmJudFap
    def set_procAdmJudFap(self, procAdmJudFap): self.procAdmJudFap = procAdmJudFap
    def hasContent_(self):
        if (
            self.aliqRat is not None or
            self.fap is not None or
            self.aliqRatAjust is not None or
            self.procAdmJudRat is not None or
            self.procAdmJudFap is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aliqGilrat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('aliqGilrat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aliqGilrat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='aliqGilrat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aliqGilrat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='aliqGilrat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.aliqRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saliqRat>%s</%saliqRat>%s' % (namespace_, self.gds_format_integer(self.aliqRat, input_name='aliqRat'), namespace_, eol_))
        if self.fap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfap>%s</%sfap>%s' % (namespace_, self.gds_format_float(self.fap, input_name='fap'), namespace_, eol_))
        if self.aliqRatAjust is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saliqRatAjust>%s</%saliqRatAjust>%s' % (namespace_, self.gds_format_float(self.aliqRatAjust, input_name='aliqRatAjust'), namespace_, eol_))
        if self.procAdmJudRat is not None:
            self.procAdmJudRat.export(outfile, level, namespace_, name_='procAdmJudRat', pretty_print=pretty_print)
        if self.procAdmJudFap is not None:
            self.procAdmJudFap.export(outfile, level, namespace_, name_='procAdmJudFap', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'aliqRat':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'aliqRat')
            self.aliqRat = ival_
        elif nodeName_ == 'fap':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fap')
            self.fap = fval_
        elif nodeName_ == 'aliqRatAjust':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'aliqRatAjust')
            self.aliqRatAjust = fval_
        elif nodeName_ == 'procAdmJudRat':
            obj_ = procAdmJudRat.factory()
            obj_.build(child_)
            self.procAdmJudRat = obj_
            obj_.original_tagname_ = 'procAdmJudRat'
        elif nodeName_ == 'procAdmJudFap':
            obj_ = procAdmJudFap.factory()
            obj_.build(child_)
            self.procAdmJudFap = obj_
            obj_.original_tagname_ = 'procAdmJudFap'
# end class aliqGilrat


class aliqRat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, aliqRat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if aliqRat.subclass:
            return aliqRat.subclass(*args_, **kwargs_)
        else:
            return aliqRat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aliqRat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('aliqRat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aliqRat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='aliqRat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aliqRat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='aliqRat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class aliqRat


class fap(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fap.subclass:
            return fap.subclass(*args_, **kwargs_)
        else:
            return fap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fap', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fap', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fap'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fap', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fap


class aliqRatAjust(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, aliqRatAjust)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if aliqRatAjust.subclass:
            return aliqRatAjust.subclass(*args_, **kwargs_)
        else:
            return aliqRatAjust(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aliqRatAjust', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('aliqRatAjust')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aliqRatAjust')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='aliqRatAjust', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aliqRatAjust'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='aliqRatAjust', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class aliqRatAjust


class procAdmJudRat(GeneratedsSuper):
    """Registro que identifica, em caso de existência, o processo
    administrativo ou judicial em que houve decisão/sentença
    favorável ao contribuinte modificando a alíquota RAT da empresa."""
    subclass = None
    superclass = None
    def __init__(self, tpProc=None, nrProc=None, codSusp=None):
        self.original_tagname_ = None
        self.tpProc = tpProc
        self.nrProc = nrProc
        self.codSusp = codSusp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procAdmJudRat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procAdmJudRat.subclass:
            return procAdmJudRat.subclass(*args_, **kwargs_)
        else:
            return procAdmJudRat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpProc(self): return self.tpProc
    def set_tpProc(self, tpProc): self.tpProc = tpProc
    def get_nrProc(self): return self.nrProc
    def set_nrProc(self, nrProc): self.nrProc = nrProc
    def get_codSusp(self): return self.codSusp
    def set_codSusp(self, codSusp): self.codSusp = codSusp
    def hasContent_(self):
        if (
            self.tpProc is not None or
            self.nrProc is not None or
            self.codSusp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='procAdmJudRat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procAdmJudRat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='procAdmJudRat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='procAdmJudRat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='procAdmJudRat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procAdmJudRat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpProc>%s</%stpProc>%s' % (namespace_, self.gds_format_integer(self.tpProc, input_name='tpProc'), namespace_, eol_))
        if self.nrProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrProc>%s</%snrProc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrProc), input_name='nrProc')), namespace_, eol_))
        if self.codSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodSusp>%s</%scodSusp>%s' % (namespace_, self.gds_format_integer(self.codSusp, input_name='codSusp'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpProc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpProc')
            self.tpProc = ival_
        elif nodeName_ == 'nrProc':
            nrProc_ = child_.text
            nrProc_ = self.gds_validate_string(nrProc_, node, 'nrProc')
            self.nrProc = nrProc_
        elif nodeName_ == 'codSusp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codSusp')
            self.codSusp = ival_
# end class procAdmJudRat


class tpProc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpProc.subclass:
            return tpProc.subclass(*args_, **kwargs_)
        else:
            return tpProc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpProc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpProc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpProc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpProc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpProc


class nrProc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrProc.subclass:
            return nrProc.subclass(*args_, **kwargs_)
        else:
            return nrProc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrProc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrProc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrProc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrProc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrProc


class codSusp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codSusp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codSusp.subclass:
            return codSusp.subclass(*args_, **kwargs_)
        else:
            return codSusp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codSusp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codSusp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codSusp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codSusp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codSusp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codSusp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codSusp


class procAdmJudFap(GeneratedsSuper):
    """Registro que identifica, em caso de existência, o processo
    administrativo/judicial em que houve decisão ou sentença
    favorável ao contribuinte suspendendo ou alterando a alíquota
    FAP aplicável ao contribuinte."""
    subclass = None
    superclass = None
    def __init__(self, tpProc=None, nrProc=None, codSusp=None):
        self.original_tagname_ = None
        self.tpProc = tpProc
        self.nrProc = nrProc
        self.codSusp = codSusp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procAdmJudFap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procAdmJudFap.subclass:
            return procAdmJudFap.subclass(*args_, **kwargs_)
        else:
            return procAdmJudFap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpProc(self): return self.tpProc
    def set_tpProc(self, tpProc): self.tpProc = tpProc
    def get_nrProc(self): return self.nrProc
    def set_nrProc(self, nrProc): self.nrProc = nrProc
    def get_codSusp(self): return self.codSusp
    def set_codSusp(self, codSusp): self.codSusp = codSusp
    def hasContent_(self):
        if (
            self.tpProc is not None or
            self.nrProc is not None or
            self.codSusp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='procAdmJudFap', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procAdmJudFap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='procAdmJudFap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='procAdmJudFap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='procAdmJudFap'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procAdmJudFap', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpProc>%s</%stpProc>%s' % (namespace_, self.gds_format_integer(self.tpProc, input_name='tpProc'), namespace_, eol_))
        if self.nrProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrProc>%s</%snrProc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrProc), input_name='nrProc')), namespace_, eol_))
        if self.codSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodSusp>%s</%scodSusp>%s' % (namespace_, self.gds_format_integer(self.codSusp, input_name='codSusp'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpProc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpProc')
            self.tpProc = ival_
        elif nodeName_ == 'nrProc':
            nrProc_ = child_.text
            nrProc_ = self.gds_validate_string(nrProc_, node, 'nrProc')
            self.nrProc = nrProc_
        elif nodeName_ == 'codSusp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codSusp')
            self.codSusp = ival_
# end class procAdmJudFap


class infoCaepf(GeneratedsSuper):
    """Informações relativas ao Cadastro da Atividade Econômica da Pessoa
    Física - CAEPF."""
    subclass = None
    superclass = None
    def __init__(self, tpCaepf=None):
        self.original_tagname_ = None
        self.tpCaepf = tpCaepf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoCaepf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoCaepf.subclass:
            return infoCaepf.subclass(*args_, **kwargs_)
        else:
            return infoCaepf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpCaepf(self): return self.tpCaepf
    def set_tpCaepf(self, tpCaepf): self.tpCaepf = tpCaepf
    def hasContent_(self):
        if (
            self.tpCaepf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoCaepf', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoCaepf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoCaepf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoCaepf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoCaepf'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoCaepf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpCaepf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpCaepf>%s</%stpCaepf>%s' % (namespace_, self.gds_format_integer(self.tpCaepf, input_name='tpCaepf'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpCaepf':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpCaepf')
            self.tpCaepf = ival_
# end class infoCaepf


class tpCaepf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpCaepf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpCaepf.subclass:
            return tpCaepf.subclass(*args_, **kwargs_)
        else:
            return tpCaepf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpCaepf', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpCaepf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpCaepf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpCaepf', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpCaepf'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpCaepf', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpCaepf


class infoObra(GeneratedsSuper):
    """Registro preenchido exclusivamente por empresa construtora
    enquadrada nos Arts. 7 a 9 da Lei 12.546/2011, relacionando os
    estabelecimentos inscritos no CNO, para indicar a substituição
    ou não da contribuição patronal incidente sobre a remuneração
    dos trabalhadores de obra de construção civil."""
    subclass = None
    superclass = None
    def __init__(self, indSubstPatrObra=None):
        self.original_tagname_ = None
        self.indSubstPatrObra = indSubstPatrObra
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoObra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoObra.subclass:
            return infoObra.subclass(*args_, **kwargs_)
        else:
            return infoObra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indSubstPatrObra(self): return self.indSubstPatrObra
    def set_indSubstPatrObra(self, indSubstPatrObra): self.indSubstPatrObra = indSubstPatrObra
    def hasContent_(self):
        if (
            self.indSubstPatrObra is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoObra', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoObra')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoObra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoObra', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoObra'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoObra', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indSubstPatrObra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSubstPatrObra>%s</%sindSubstPatrObra>%s' % (namespace_, self.gds_format_integer(self.indSubstPatrObra, input_name='indSubstPatrObra'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indSubstPatrObra':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'indSubstPatrObra')
            self.indSubstPatrObra = ival_
# end class infoObra


class indSubstPatrObra(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indSubstPatrObra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indSubstPatrObra.subclass:
            return indSubstPatrObra.subclass(*args_, **kwargs_)
        else:
            return indSubstPatrObra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indSubstPatrObra', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indSubstPatrObra')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indSubstPatrObra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indSubstPatrObra', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indSubstPatrObra'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indSubstPatrObra', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indSubstPatrObra


class infoTrab(GeneratedsSuper):
    """Informações Trabalhistas relativas ao estabelecimento"""
    subclass = None
    superclass = None
    def __init__(self, regPt=None, infoApr=None, infoPCD=None):
        self.original_tagname_ = None
        self.regPt = regPt
        self.infoApr = infoApr
        self.infoPCD = infoPCD
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoTrab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoTrab.subclass:
            return infoTrab.subclass(*args_, **kwargs_)
        else:
            return infoTrab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regPt(self): return self.regPt
    def set_regPt(self, regPt): self.regPt = regPt
    def get_infoApr(self): return self.infoApr
    def set_infoApr(self, infoApr): self.infoApr = infoApr
    def get_infoPCD(self): return self.infoPCD
    def set_infoPCD(self, infoPCD): self.infoPCD = infoPCD
    def hasContent_(self):
        if (
            self.regPt is not None or
            self.infoApr is not None or
            self.infoPCD is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoTrab', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoTrab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoTrab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoTrab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoTrab'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoTrab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.regPt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregPt>%s</%sregPt>%s' % (namespace_, self.gds_format_integer(self.regPt, input_name='regPt'), namespace_, eol_))
        if self.infoApr is not None:
            self.infoApr.export(outfile, level, namespace_, name_='infoApr', pretty_print=pretty_print)
        if self.infoPCD is not None:
            self.infoPCD.export(outfile, level, namespace_, name_='infoPCD', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'regPt':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'regPt')
            self.regPt = ival_
        elif nodeName_ == 'infoApr':
            obj_ = infoApr.factory()
            obj_.build(child_)
            self.infoApr = obj_
            obj_.original_tagname_ = 'infoApr'
        elif nodeName_ == 'infoPCD':
            obj_ = infoPCD.factory()
            obj_.build(child_)
            self.infoPCD = obj_
            obj_.original_tagname_ = 'infoPCD'
# end class infoTrab


class regPt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, regPt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if regPt.subclass:
            return regPt.subclass(*args_, **kwargs_)
        else:
            return regPt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='regPt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('regPt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='regPt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='regPt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='regPt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='regPt', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class regPt


class infoApr(GeneratedsSuper):
    """Informações relacionadas à contratação de aprendiz"""
    subclass = None
    superclass = None
    def __init__(self, contApr=None, nrProcJud=None, contEntEd=None, infoEntEduc=None):
        self.original_tagname_ = None
        self.contApr = contApr
        self.nrProcJud = nrProcJud
        self.contEntEd = contEntEd
        if infoEntEduc is None:
            self.infoEntEduc = []
        else:
            self.infoEntEduc = infoEntEduc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoApr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoApr.subclass:
            return infoApr.subclass(*args_, **kwargs_)
        else:
            return infoApr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contApr(self): return self.contApr
    def set_contApr(self, contApr): self.contApr = contApr
    def get_nrProcJud(self): return self.nrProcJud
    def set_nrProcJud(self, nrProcJud): self.nrProcJud = nrProcJud
    def get_contEntEd(self): return self.contEntEd
    def set_contEntEd(self, contEntEd): self.contEntEd = contEntEd
    def get_infoEntEduc(self): return self.infoEntEduc
    def set_infoEntEduc(self, infoEntEduc): self.infoEntEduc = infoEntEduc
    def add_infoEntEduc(self, value): self.infoEntEduc.append(value)
    def insert_infoEntEduc_at(self, index, value): self.infoEntEduc.insert(index, value)
    def replace_infoEntEduc_at(self, index, value): self.infoEntEduc[index] = value
    def hasContent_(self):
        if (
            self.contApr is not None or
            self.nrProcJud is not None or
            self.contEntEd is not None or
            self.infoEntEduc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoApr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoApr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoApr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoApr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoApr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoApr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contApr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontApr>%s</%scontApr>%s' % (namespace_, self.gds_format_integer(self.contApr, input_name='contApr'), namespace_, eol_))
        if self.nrProcJud is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrProcJud>%s</%snrProcJud>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrProcJud), input_name='nrProcJud')), namespace_, eol_))
        if self.contEntEd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontEntEd>%s</%scontEntEd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.contEntEd), input_name='contEntEd')), namespace_, eol_))
        for infoEntEduc_ in self.infoEntEduc:
            infoEntEduc_.export(outfile, level, namespace_, name_='infoEntEduc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contApr':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'contApr')
            self.contApr = ival_
        elif nodeName_ == 'nrProcJud':
            nrProcJud_ = child_.text
            nrProcJud_ = self.gds_validate_string(nrProcJud_, node, 'nrProcJud')
            self.nrProcJud = nrProcJud_
        elif nodeName_ == 'contEntEd':
            contEntEd_ = child_.text
            contEntEd_ = self.gds_validate_string(contEntEd_, node, 'contEntEd')
            self.contEntEd = contEntEd_
        elif nodeName_ == 'infoEntEduc':
            obj_ = infoEntEduc.factory()
            obj_.build(child_)
            self.infoEntEduc.append(obj_)
            obj_.original_tagname_ = 'infoEntEduc'
# end class infoApr


class contApr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contApr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contApr.subclass:
            return contApr.subclass(*args_, **kwargs_)
        else:
            return contApr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contApr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('contApr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contApr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='contApr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contApr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='contApr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contApr


class nrProcJud(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nrProcJud)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nrProcJud.subclass:
            return nrProcJud.subclass(*args_, **kwargs_)
        else:
            return nrProcJud(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nrProcJud', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nrProcJud')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nrProcJud')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nrProcJud', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nrProcJud'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nrProcJud', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nrProcJud


class contEntEd(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contEntEd)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contEntEd.subclass:
            return contEntEd.subclass(*args_, **kwargs_)
        else:
            return contEntEd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contEntEd', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('contEntEd')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contEntEd')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='contEntEd', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contEntEd'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='contEntEd', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contEntEd


class infoEntEduc(GeneratedsSuper):
    """Identificação da(s) entidade(s) educativa(s) ou de prática
    desportiva"""
    subclass = None
    superclass = None
    def __init__(self, nrInsc=None):
        self.original_tagname_ = None
        self.nrInsc = nrInsc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoEntEduc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoEntEduc.subclass:
            return infoEntEduc.subclass(*args_, **kwargs_)
        else:
            return infoEntEduc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def hasContent_(self):
        if (
            self.nrInsc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoEntEduc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoEntEduc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoEntEduc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoEntEduc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoEntEduc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoEntEduc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrInsc>%s</%snrInsc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
# end class infoEntEduc


class infoPCD(GeneratedsSuper):
    """Informações sobre a contratação de pessoa com deficiência (PCD).
    Essa informação deve ser prestada apenas no estabelecimento
    "Matriz"."""
    subclass = None
    superclass = None
    def __init__(self, contPCD=None, nrProcJud=None):
        self.original_tagname_ = None
        self.contPCD = contPCD
        self.nrProcJud = nrProcJud
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoPCD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoPCD.subclass:
            return infoPCD.subclass(*args_, **kwargs_)
        else:
            return infoPCD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contPCD(self): return self.contPCD
    def set_contPCD(self, contPCD): self.contPCD = contPCD
    def get_nrProcJud(self): return self.nrProcJud
    def set_nrProcJud(self, nrProcJud): self.nrProcJud = nrProcJud
    def hasContent_(self):
        if (
            self.contPCD is not None or
            self.nrProcJud is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infoPCD', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoPCD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infoPCD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infoPCD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infoPCD'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infoPCD', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contPCD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontPCD>%s</%scontPCD>%s' % (namespace_, self.gds_format_integer(self.contPCD, input_name='contPCD'), namespace_, eol_))
        if self.nrProcJud is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snrProcJud>%s</%snrProcJud>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nrProcJud), input_name='nrProcJud')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contPCD':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'contPCD')
            self.contPCD = ival_
        elif nodeName_ == 'nrProcJud':
            nrProcJud_ = child_.text
            nrProcJud_ = self.gds_validate_string(nrProcJud_, node, 'nrProcJud')
            self.nrProcJud = nrProcJud_
# end class infoPCD


class contPCD(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contPCD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contPCD.subclass:
            return contPCD.subclass(*args_, **kwargs_)
        else:
            return contPCD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contPCD', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('contPCD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contPCD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='contPCD', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contPCD'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='contPCD', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contPCD


class TPeriodoValidade(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iniValid=None, fimValid=None):
        self.original_tagname_ = None
        self.iniValid = iniValid
        self.fimValid = fimValid
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TPeriodoValidade)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TPeriodoValidade.subclass:
            return TPeriodoValidade.subclass(*args_, **kwargs_)
        else:
            return TPeriodoValidade(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iniValid(self): return self.iniValid
    def set_iniValid(self, iniValid): self.iniValid = iniValid
    def get_fimValid(self): return self.fimValid
    def set_fimValid(self, fimValid): self.fimValid = fimValid
    def hasContent_(self):
        if (
            self.iniValid is not None or
            self.fimValid is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TPeriodoValidade', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TPeriodoValidade')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TPeriodoValidade')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TPeriodoValidade', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TPeriodoValidade'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TPeriodoValidade', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.iniValid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siniValid>%s</%siniValid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.iniValid), input_name='iniValid')), namespace_, eol_))
        if self.fimValid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfimValid>%s</%sfimValid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fimValid), input_name='fimValid')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iniValid':
            iniValid_ = child_.text
            iniValid_ = self.gds_validate_string(iniValid_, node, 'iniValid')
            self.iniValid = iniValid_
        elif nodeName_ == 'fimValid':
            fimValid_ = child_.text
            fimValid_ = self.gds_validate_string(fimValid_, node, 'fimValid')
            self.fimValid = fimValid_
# end class TPeriodoValidade


GDSClassesMapping = {
    'dadosEstab': TDadosEstab,
    'ideEmpregador': TEmpregador,
    'ideEstab': TIdeEstab,
    'ideEvento': TIdeCadastro,
    'novaValidade': TPeriodoValidade,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from evtTabEstab import *\n\n')
        sys.stdout.write('import evtTabEstab as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "TDadosEstab",
    "TEmpregador",
    "TIdeCadastro",
    "TIdeEstab",
    "TPeriodoValidade",
    "eSocial"
]
